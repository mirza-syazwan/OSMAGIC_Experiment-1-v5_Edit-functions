{
  "version": "1.0",
  "maxHistory": 10,
  "history": [
    {
      "promptNumber": 1,
      "promptText": "in preview edit mode, the nodes are not shifting with the ways. but its translated in JOSM well. can you fix the preview mode since the visual aspect is important for the ops to understand what is the changesto be done.",
      "timestamp": "2025-12-16T17:40:31.327031",
      "filesBefore": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer)) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n            });\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers (but don't update during drag to avoid feedback loop)\n                                if (!layer._updatingMarkers) {\n                                    layer._updatingMarkers = true;\n                                    // Use requestAnimationFrame to batch marker updates\n                                    requestAnimationFrame(() => {\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    });\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    const newLatlng = e.target.getLatLng();\n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      },
      "filesAfter": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer)) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n            });\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers in real-time during drag for visual feedback\n                                // Update marker positions directly (synchronously) so they move with the way\n                                if (layer._vertexMarkers && layer._vertexMarkers.length === newLatLngs.length) {\n                                    // Update existing markers directly for immediate visual feedback\n                                    newLatLngs.forEach((latlng, index) => {\n                                        if (layer._vertexMarkers[index]) {\n                                            let lat, lng;\n                                            if (latlng instanceof L.LatLng) {\n                                                lat = latlng.lat;\n                                                lng = latlng.lng;\n                                            } else if (Array.isArray(latlng)) {\n                                                lat = latlng[0];\n                                                lng = latlng[1];\n                                            } else {\n                                                lat = latlng.lat || latlng[0];\n                                                lng = latlng.lng || latlng[1];\n                                            }\n                                            layer._vertexMarkers[index].setLatLng([lat, lng]);\n                                        }\n                                    });\n                                } else {\n                                    // If marker count doesn't match, recreate markers (shouldn't happen during drag)\n                                    if (!layer._updatingMarkers) {\n                                        layer._updatingMarkers = true;\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    }\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    const newLatlng = e.target.getLatLng();\n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      }
    },
    {
      "promptNumber": 2,
      "promptText": "can you have an OSM data layer when you load in the preview page, so that the edit can be done directly on the preview page?",
      "timestamp": "2025-12-16T17:46:57.203759",
      "filesBefore": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer)) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n            });\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers in real-time during drag for visual feedback\n                                // Update marker positions directly (synchronously) so they move with the way\n                                if (layer._vertexMarkers && layer._vertexMarkers.length === newLatLngs.length) {\n                                    // Update existing markers directly for immediate visual feedback\n                                    newLatLngs.forEach((latlng, index) => {\n                                        if (layer._vertexMarkers[index]) {\n                                            let lat, lng;\n                                            if (latlng instanceof L.LatLng) {\n                                                lat = latlng.lat;\n                                                lng = latlng.lng;\n                                            } else if (Array.isArray(latlng)) {\n                                                lat = latlng[0];\n                                                lng = latlng[1];\n                                            } else {\n                                                lat = latlng.lat || latlng[0];\n                                                lng = latlng.lng || latlng[1];\n                                            }\n                                            layer._vertexMarkers[index].setLatLng([lat, lng]);\n                                        }\n                                    });\n                                } else {\n                                    // If marker count doesn't match, recreate markers (shouldn't happen during drag)\n                                    if (!layer._updatingMarkers) {\n                                        layer._updatingMarkers = true;\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    }\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    const newLatlng = e.target.getLatLng();\n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      },
      "filesAfter": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        this.osmDataLayer = null; // OSM data layer for preview\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async loadOsmDataForPreview(sequence) {\n        try {\n            // Calculate bounding box\n            const bbox = this.calculateBoundingBox(sequence);\n            \n            // Remove existing OSM data layer if present\n            if (this.osmDataLayer) {\n                this.map.removeLayer(this.osmDataLayer);\n                this.osmDataLayer = null;\n            }\n            \n            // Create Overpass API query to get all ways and nodes in the bounding box\n            const overpassQuery = `\n                [out:xml][timeout:25];\n                (\n                  way[\"highway\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                  relation[\"type\"=\"route\"][\"route\"~\"^(bus|tram|train|subway|light_rail|trolleybus|ferry|monorail|aerialway|share_taxi|funicular)$\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                );\n                (._;>;);\n                out body;\n            `;\n            \n            // Fetch OSM data from Overpass API\n            const overpassUrl = 'https://overpass-api.de/api/interpreter';\n            console.log('Loading OSM data for preview...');\n            \n            const response = await fetch(overpassUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(overpassQuery)}`\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Overpass API error: ${response.status}`);\n            }\n            \n            const osmXml = await response.text();\n            \n            // Parse OSM XML and convert to GeoJSON\n            const osmGeoJson = this.parseOsmXmlToGeoJson(osmXml);\n            \n            if (osmGeoJson && osmGeoJson.features && osmGeoJson.features.length > 0) {\n                // Add OSM data as a layer with distinct styling (gray, thinner)\n                this.osmDataLayer = L.geoJSON(osmGeoJson, {\n                    style: (feature) => {\n                        // Style OSM data differently from GPS trace\n                        const highway = feature.properties?.highway;\n                        let color = '#888888'; // Default gray\n                        let weight = 2;\n                        \n                        // Color code by highway type\n                        if (highway === 'motorway' || highway === 'trunk') {\n                            color = '#ff6b6b';\n                            weight = 3;\n                        } else if (highway === 'primary') {\n                            color = '#ffa500';\n                            weight = 2.5;\n                        } else if (highway === 'secondary') {\n                            color = '#ffd700';\n                            weight = 2;\n                        } else if (highway === 'tertiary') {\n                            color = '#90ee90';\n                            weight = 2;\n                        } else if (highway === 'residential' || highway === 'unclassified') {\n                            color = '#c0c0c0';\n                            weight = 1.5;\n                        }\n                        \n                        return {\n                            color: color,\n                            weight: weight,\n                            opacity: 0.6,\n                            dashArray: '5, 5' // Dashed line to distinguish from GPS trace\n                        };\n                    },\n                    onEachFeature: (feature, layer) => {\n                        // Mark this layer as OSM data layer\n                        layer._isOsmDataLayer = true;\n                    }\n                }).addTo(this.map);\n                \n                console.log(`Loaded ${osmGeoJson.features.length} OSM features for preview`);\n            } else {\n                console.log('No OSM data found in the area');\n            }\n        } catch (error) {\n            console.warn('Failed to load OSM data for preview:', error);\n            // Continue without OSM data - not critical\n        }\n    }\n\n    parseOsmXmlToGeoJson(osmXml) {\n        try {\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(osmXml, 'text/xml');\n            \n            // Check for parsing errors\n            const parserError = xmlDoc.querySelector('parsererror');\n            if (parserError) {\n                throw new Error('XML parsing error');\n            }\n            \n            const nodes = new Map();\n            const ways = [];\n            const relations = [];\n            \n            // Parse nodes\n            xmlDoc.querySelectorAll('node').forEach(nodeEl => {\n                const id = nodeEl.getAttribute('id');\n                const lat = parseFloat(nodeEl.getAttribute('lat'));\n                const lon = parseFloat(nodeEl.getAttribute('lon'));\n                \n                const tags = {};\n                nodeEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                nodes.set(id, { id, lat, lon, tags });\n            });\n            \n            // Parse ways\n            xmlDoc.querySelectorAll('way').forEach(wayEl => {\n                const id = wayEl.getAttribute('id');\n                const ndRefs = [];\n                \n                wayEl.querySelectorAll('nd').forEach(nd => {\n                    ndRefs.push(nd.getAttribute('ref'));\n                });\n                \n                const tags = {};\n                wayEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                // Only include ways with highway tag (roads)\n                if (tags.highway) {\n                    ways.push({ id, ndRefs, tags });\n                }\n            });\n            \n            // Convert ways to GeoJSON LineStrings\n            const features = ways.map(way => {\n                const coordinates = way.ndRefs\n                    .map(ref => {\n                        const node = nodes.get(ref);\n                        if (node) {\n                            return [node.lon, node.lat];\n                        }\n                        return null;\n                    })\n                    .filter(coord => coord !== null);\n                \n                if (coordinates.length < 2) {\n                    return null; // Skip invalid ways\n                }\n                \n                return {\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        ...way.tags,\n                        osm_id: way.id\n                    }\n                };\n            }).filter(f => f !== null);\n            \n            return {\n                type: 'FeatureCollection',\n                features: features\n            };\n        } catch (error) {\n            console.error('Error parsing OSM XML:', error);\n            return { type: 'FeatureCollection', features: [] };\n        }\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    async previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer and OSM data layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer) && !layer._isOsmDataLayer) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n            \n            // Load OSM data for the area\n            this.loadOsmDataForPreview(sequence);\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n            });\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers in real-time during drag for visual feedback\n                                // Update marker positions directly (synchronously) so they move with the way\n                                if (layer._vertexMarkers && layer._vertexMarkers.length === newLatLngs.length) {\n                                    // Update existing markers directly for immediate visual feedback\n                                    newLatLngs.forEach((latlng, index) => {\n                                        if (layer._vertexMarkers[index]) {\n                                            let lat, lng;\n                                            if (latlng instanceof L.LatLng) {\n                                                lat = latlng.lat;\n                                                lng = latlng.lng;\n                                            } else if (Array.isArray(latlng)) {\n                                                lat = latlng[0];\n                                                lng = latlng[1];\n                                            } else {\n                                                lat = latlng.lat || latlng[0];\n                                                lng = latlng.lng || latlng[1];\n                                            }\n                                            layer._vertexMarkers[index].setLatLng([lat, lng]);\n                                        }\n                                    });\n                                } else {\n                                    // If marker count doesn't match, recreate markers (shouldn't happen during drag)\n                                    if (!layer._updatingMarkers) {\n                                        layer._updatingMarkers = true;\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    }\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    const newLatlng = e.target.getLatLng();\n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      }
    },
    {
      "promptNumber": 3,
      "promptText": "ok the OSM layer in the edit mode (in preview page) should be editable also.",
      "timestamp": "2025-12-16T17:57:08.313275",
      "filesBefore": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        this.osmDataLayer = null; // OSM data layer for preview\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async loadOsmDataForPreview(sequence) {\n        try {\n            // Calculate bounding box\n            const bbox = this.calculateBoundingBox(sequence);\n            \n            // Remove existing OSM data layer if present\n            if (this.osmDataLayer) {\n                this.map.removeLayer(this.osmDataLayer);\n                this.osmDataLayer = null;\n            }\n            \n            // Create Overpass API query to get all ways and nodes in the bounding box\n            const overpassQuery = `\n                [out:xml][timeout:25];\n                (\n                  way[\"highway\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                  relation[\"type\"=\"route\"][\"route\"~\"^(bus|tram|train|subway|light_rail|trolleybus|ferry|monorail|aerialway|share_taxi|funicular)$\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                );\n                (._;>;);\n                out body;\n            `;\n            \n            // Fetch OSM data from Overpass API\n            const overpassUrl = 'https://overpass-api.de/api/interpreter';\n            console.log('Loading OSM data for preview...');\n            \n            const response = await fetch(overpassUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(overpassQuery)}`\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Overpass API error: ${response.status}`);\n            }\n            \n            const osmXml = await response.text();\n            \n            // Parse OSM XML and convert to GeoJSON\n            const osmGeoJson = this.parseOsmXmlToGeoJson(osmXml);\n            \n            if (osmGeoJson && osmGeoJson.features && osmGeoJson.features.length > 0) {\n                // Add OSM data as a layer with distinct styling (gray, thinner)\n                this.osmDataLayer = L.geoJSON(osmGeoJson, {\n                    style: (feature) => {\n                        // Style OSM data differently from GPS trace\n                        const highway = feature.properties?.highway;\n                        let color = '#888888'; // Default gray\n                        let weight = 2;\n                        \n                        // Color code by highway type\n                        if (highway === 'motorway' || highway === 'trunk') {\n                            color = '#ff6b6b';\n                            weight = 3;\n                        } else if (highway === 'primary') {\n                            color = '#ffa500';\n                            weight = 2.5;\n                        } else if (highway === 'secondary') {\n                            color = '#ffd700';\n                            weight = 2;\n                        } else if (highway === 'tertiary') {\n                            color = '#90ee90';\n                            weight = 2;\n                        } else if (highway === 'residential' || highway === 'unclassified') {\n                            color = '#c0c0c0';\n                            weight = 1.5;\n                        }\n                        \n                        return {\n                            color: color,\n                            weight: weight,\n                            opacity: 0.6,\n                            dashArray: '5, 5' // Dashed line to distinguish from GPS trace\n                        };\n                    },\n                    onEachFeature: (feature, layer) => {\n                        // Mark this layer as OSM data layer\n                        layer._isOsmDataLayer = true;\n                    }\n                }).addTo(this.map);\n                \n                console.log(`Loaded ${osmGeoJson.features.length} OSM features for preview`);\n            } else {\n                console.log('No OSM data found in the area');\n            }\n        } catch (error) {\n            console.warn('Failed to load OSM data for preview:', error);\n            // Continue without OSM data - not critical\n        }\n    }\n\n    parseOsmXmlToGeoJson(osmXml) {\n        try {\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(osmXml, 'text/xml');\n            \n            // Check for parsing errors\n            const parserError = xmlDoc.querySelector('parsererror');\n            if (parserError) {\n                throw new Error('XML parsing error');\n            }\n            \n            const nodes = new Map();\n            const ways = [];\n            const relations = [];\n            \n            // Parse nodes\n            xmlDoc.querySelectorAll('node').forEach(nodeEl => {\n                const id = nodeEl.getAttribute('id');\n                const lat = parseFloat(nodeEl.getAttribute('lat'));\n                const lon = parseFloat(nodeEl.getAttribute('lon'));\n                \n                const tags = {};\n                nodeEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                nodes.set(id, { id, lat, lon, tags });\n            });\n            \n            // Parse ways\n            xmlDoc.querySelectorAll('way').forEach(wayEl => {\n                const id = wayEl.getAttribute('id');\n                const ndRefs = [];\n                \n                wayEl.querySelectorAll('nd').forEach(nd => {\n                    ndRefs.push(nd.getAttribute('ref'));\n                });\n                \n                const tags = {};\n                wayEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                // Only include ways with highway tag (roads)\n                if (tags.highway) {\n                    ways.push({ id, ndRefs, tags });\n                }\n            });\n            \n            // Convert ways to GeoJSON LineStrings\n            const features = ways.map(way => {\n                const coordinates = way.ndRefs\n                    .map(ref => {\n                        const node = nodes.get(ref);\n                        if (node) {\n                            return [node.lon, node.lat];\n                        }\n                        return null;\n                    })\n                    .filter(coord => coord !== null);\n                \n                if (coordinates.length < 2) {\n                    return null; // Skip invalid ways\n                }\n                \n                return {\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        ...way.tags,\n                        osm_id: way.id\n                    }\n                };\n            }).filter(f => f !== null);\n            \n            return {\n                type: 'FeatureCollection',\n                features: features\n            };\n        } catch (error) {\n            console.error('Error parsing OSM XML:', error);\n            return { type: 'FeatureCollection', features: [] };\n        }\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    async previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer and OSM data layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer) && !layer._isOsmDataLayer) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n            \n            // Load OSM data for the area\n            this.loadOsmDataForPreview(sequence);\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n            });\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers in real-time during drag for visual feedback\n                                // Update marker positions directly (synchronously) so they move with the way\n                                if (layer._vertexMarkers && layer._vertexMarkers.length === newLatLngs.length) {\n                                    // Update existing markers directly for immediate visual feedback\n                                    newLatLngs.forEach((latlng, index) => {\n                                        if (layer._vertexMarkers[index]) {\n                                            let lat, lng;\n                                            if (latlng instanceof L.LatLng) {\n                                                lat = latlng.lat;\n                                                lng = latlng.lng;\n                                            } else if (Array.isArray(latlng)) {\n                                                lat = latlng[0];\n                                                lng = latlng[1];\n                                            } else {\n                                                lat = latlng.lat || latlng[0];\n                                                lng = latlng.lng || latlng[1];\n                                            }\n                                            layer._vertexMarkers[index].setLatLng([lat, lng]);\n                                        }\n                                    });\n                                } else {\n                                    // If marker count doesn't match, recreate markers (shouldn't happen during drag)\n                                    if (!layer._updatingMarkers) {\n                                        layer._updatingMarkers = true;\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    }\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    const newLatlng = e.target.getLatLng();\n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      },
      "filesAfter": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        this.osmDataLayer = null; // OSM data layer for preview\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async loadOsmDataForPreview(sequence) {\n        try {\n            // Calculate bounding box\n            const bbox = this.calculateBoundingBox(sequence);\n            \n            // Remove existing OSM data layer if present\n            if (this.osmDataLayer) {\n                this.map.removeLayer(this.osmDataLayer);\n                this.osmDataLayer = null;\n            }\n            \n            // Create Overpass API query to get all ways and nodes in the bounding box\n            const overpassQuery = `\n                [out:xml][timeout:25];\n                (\n                  way[\"highway\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                  relation[\"type\"=\"route\"][\"route\"~\"^(bus|tram|train|subway|light_rail|trolleybus|ferry|monorail|aerialway|share_taxi|funicular)$\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                );\n                (._;>;);\n                out body;\n            `;\n            \n            // Fetch OSM data from Overpass API\n            const overpassUrl = 'https://overpass-api.de/api/interpreter';\n            console.log('Loading OSM data for preview...');\n            \n            const response = await fetch(overpassUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(overpassQuery)}`\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Overpass API error: ${response.status}`);\n            }\n            \n            const osmXml = await response.text();\n            \n            // Parse OSM XML and convert to GeoJSON\n            const osmGeoJson = this.parseOsmXmlToGeoJson(osmXml);\n            \n            if (osmGeoJson && osmGeoJson.features && osmGeoJson.features.length > 0) {\n                // Add OSM data as a layer with distinct styling (gray, thinner)\n                this.osmDataLayer = L.geoJSON(osmGeoJson, {\n                    style: (feature) => {\n                        // Style OSM data differently from GPS trace\n                        const highway = feature.properties?.highway;\n                        let color = '#888888'; // Default gray\n                        let weight = 2;\n                        \n                        // Color code by highway type\n                        if (highway === 'motorway' || highway === 'trunk') {\n                            color = '#ff6b6b';\n                            weight = 3;\n                        } else if (highway === 'primary') {\n                            color = '#ffa500';\n                            weight = 2.5;\n                        } else if (highway === 'secondary') {\n                            color = '#ffd700';\n                            weight = 2;\n                        } else if (highway === 'tertiary') {\n                            color = '#90ee90';\n                            weight = 2;\n                        } else if (highway === 'residential' || highway === 'unclassified') {\n                            color = '#c0c0c0';\n                            weight = 1.5;\n                        }\n                        \n                        return {\n                            color: color,\n                            weight: weight,\n                            opacity: 0.6,\n                            dashArray: '5, 5' // Dashed line to distinguish from GPS trace\n                        };\n                    },\n                    onEachFeature: (feature, layer) => {\n                        // Mark this layer as OSM data layer\n                        layer._isOsmDataLayer = true;\n                    }\n                }).addTo(this.map);\n                \n                console.log(`Loaded ${osmGeoJson.features.length} OSM features for preview`);\n            } else {\n                console.log('No OSM data found in the area');\n            }\n        } catch (error) {\n            console.warn('Failed to load OSM data for preview:', error);\n            // Continue without OSM data - not critical\n        }\n    }\n\n    parseOsmXmlToGeoJson(osmXml) {\n        try {\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(osmXml, 'text/xml');\n            \n            // Check for parsing errors\n            const parserError = xmlDoc.querySelector('parsererror');\n            if (parserError) {\n                throw new Error('XML parsing error');\n            }\n            \n            const nodes = new Map();\n            const ways = [];\n            const relations = [];\n            \n            // Parse nodes\n            xmlDoc.querySelectorAll('node').forEach(nodeEl => {\n                const id = nodeEl.getAttribute('id');\n                const lat = parseFloat(nodeEl.getAttribute('lat'));\n                const lon = parseFloat(nodeEl.getAttribute('lon'));\n                \n                const tags = {};\n                nodeEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                nodes.set(id, { id, lat, lon, tags });\n            });\n            \n            // Parse ways\n            xmlDoc.querySelectorAll('way').forEach(wayEl => {\n                const id = wayEl.getAttribute('id');\n                const ndRefs = [];\n                \n                wayEl.querySelectorAll('nd').forEach(nd => {\n                    ndRefs.push(nd.getAttribute('ref'));\n                });\n                \n                const tags = {};\n                wayEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                // Only include ways with highway tag (roads)\n                if (tags.highway) {\n                    ways.push({ id, ndRefs, tags });\n                }\n            });\n            \n            // Convert ways to GeoJSON LineStrings\n            const features = ways.map(way => {\n                const coordinates = way.ndRefs\n                    .map(ref => {\n                        const node = nodes.get(ref);\n                        if (node) {\n                            return [node.lon, node.lat];\n                        }\n                        return null;\n                    })\n                    .filter(coord => coord !== null);\n                \n                if (coordinates.length < 2) {\n                    return null; // Skip invalid ways\n                }\n                \n                return {\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        ...way.tags,\n                        osm_id: way.id\n                    }\n                };\n            }).filter(f => f !== null);\n            \n            return {\n                type: 'FeatureCollection',\n                features: features\n            };\n        } catch (error) {\n            console.error('Error parsing OSM XML:', error);\n            return { type: 'FeatureCollection', features: [] };\n        }\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    async previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer and OSM data layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer) && !layer._isOsmDataLayer) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n            \n            // Load OSM data for the area (async, will add to editableLayers when loaded)\n            this.loadOsmDataForPreview(sequence).then(() => {\n                // After OSM data loads, add it to editable layers\n                if (this.osmDataLayer) {\n                    this.osmDataLayer.eachLayer((layer) => {\n                        if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                            this.editableLayers.push(layer);\n                            layer.feature = layer.feature || {};\n                            layer._isOsmData = true; // Mark as OSM data\n                        }\n                    });\n                    console.log('OSM data layers added to editable layers. Total:', this.editableLayers.length);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing (GPS trace)\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n                layer._isGpsTrace = true; // Mark as GPS trace\n            });\n            \n            // Store OSM data layers for editing (if OSM data is loaded)\n            if (this.osmDataLayer) {\n                this.osmDataLayer.eachLayer((layer) => {\n                    if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                        this.editableLayers.push(layer);\n                        layer.feature = layer.feature || {};\n                        layer._isOsmData = true; // Mark as OSM data\n                    }\n                });\n            }\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker, 'GPS:', layer._isGpsTrace, 'OSM:', layer._isOsmData);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // Ensure OSM data layers are included in editable layers\n            if (this.osmDataLayer && this.osmDataLayer.eachLayer) {\n                let osmLayersAdded = 0;\n                this.osmDataLayer.eachLayer((layer) => {\n                    if ((layer instanceof L.Polyline || layer instanceof L.Polygon) && !layer._isOsmData) {\n                        // Check if already in editableLayers\n                        if (!this.editableLayers.includes(layer)) {\n                            this.editableLayers.push(layer);\n                            layer._isOsmData = true;\n                            osmLayersAdded++;\n                        }\n                    }\n                });\n                if (osmLayersAdded > 0) {\n                    console.log(`Added ${osmLayersAdded} OSM data layers to editable layers`);\n                }\n            }\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers (including OSM data)');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers in real-time during drag for visual feedback\n                                // Update marker positions directly (synchronously) so they move with the way\n                                if (layer._vertexMarkers && layer._vertexMarkers.length === newLatLngs.length) {\n                                    // Update existing markers directly for immediate visual feedback\n                                    newLatLngs.forEach((latlng, index) => {\n                                        if (layer._vertexMarkers[index]) {\n                                            let lat, lng;\n                                            if (latlng instanceof L.LatLng) {\n                                                lat = latlng.lat;\n                                                lng = latlng.lng;\n                                            } else if (Array.isArray(latlng)) {\n                                                lat = latlng[0];\n                                                lng = latlng[1];\n                                            } else {\n                                                lat = latlng.lat || latlng[0];\n                                                lng = latlng.lng || latlng[1];\n                                            }\n                                            layer._vertexMarkers[index].setLatLng([lat, lng]);\n                                        }\n                                    });\n                                } else {\n                                    // If marker count doesn't match, recreate markers (shouldn't happen during drag)\n                                    if (!layer._updatingMarkers) {\n                                        layer._updatingMarkers = true;\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    }\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    const newLatlng = e.target.getLatLng();\n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      }
    },
    {
      "promptNumber": 4,
      "promptText": "yes please proceed.",
      "timestamp": "2025-12-16T18:14:14.653539",
      "filesBefore": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        this.osmDataLayer = null; // OSM data layer for preview\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async loadOsmDataForPreview(sequence) {\n        try {\n            // Calculate bounding box\n            const bbox = this.calculateBoundingBox(sequence);\n            \n            // Remove existing OSM data layer if present\n            if (this.osmDataLayer) {\n                this.map.removeLayer(this.osmDataLayer);\n                this.osmDataLayer = null;\n            }\n            \n            // Create Overpass API query to get all ways and nodes in the bounding box\n            const overpassQuery = `\n                [out:xml][timeout:25];\n                (\n                  way[\"highway\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                  relation[\"type\"=\"route\"][\"route\"~\"^(bus|tram|train|subway|light_rail|trolleybus|ferry|monorail|aerialway|share_taxi|funicular)$\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                );\n                (._;>;);\n                out body;\n            `;\n            \n            // Fetch OSM data from Overpass API\n            const overpassUrl = 'https://overpass-api.de/api/interpreter';\n            console.log('Loading OSM data for preview...');\n            \n            const response = await fetch(overpassUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(overpassQuery)}`\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Overpass API error: ${response.status}`);\n            }\n            \n            const osmXml = await response.text();\n            \n            // Parse OSM XML and convert to GeoJSON\n            const osmGeoJson = this.parseOsmXmlToGeoJson(osmXml);\n            \n            if (osmGeoJson && osmGeoJson.features && osmGeoJson.features.length > 0) {\n                // Add OSM data as a layer with distinct styling (gray, thinner)\n                this.osmDataLayer = L.geoJSON(osmGeoJson, {\n                    style: (feature) => {\n                        // Style OSM data differently from GPS trace\n                        const highway = feature.properties?.highway;\n                        let color = '#888888'; // Default gray\n                        let weight = 2;\n                        \n                        // Color code by highway type\n                        if (highway === 'motorway' || highway === 'trunk') {\n                            color = '#ff6b6b';\n                            weight = 3;\n                        } else if (highway === 'primary') {\n                            color = '#ffa500';\n                            weight = 2.5;\n                        } else if (highway === 'secondary') {\n                            color = '#ffd700';\n                            weight = 2;\n                        } else if (highway === 'tertiary') {\n                            color = '#90ee90';\n                            weight = 2;\n                        } else if (highway === 'residential' || highway === 'unclassified') {\n                            color = '#c0c0c0';\n                            weight = 1.5;\n                        }\n                        \n                        return {\n                            color: color,\n                            weight: weight,\n                            opacity: 0.6,\n                            dashArray: '5, 5' // Dashed line to distinguish from GPS trace\n                        };\n                    },\n                    onEachFeature: (feature, layer) => {\n                        // Mark this layer as OSM data layer\n                        layer._isOsmDataLayer = true;\n                    }\n                }).addTo(this.map);\n                \n                console.log(`Loaded ${osmGeoJson.features.length} OSM features for preview`);\n            } else {\n                console.log('No OSM data found in the area');\n            }\n        } catch (error) {\n            console.warn('Failed to load OSM data for preview:', error);\n            // Continue without OSM data - not critical\n        }\n    }\n\n    parseOsmXmlToGeoJson(osmXml) {\n        try {\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(osmXml, 'text/xml');\n            \n            // Check for parsing errors\n            const parserError = xmlDoc.querySelector('parsererror');\n            if (parserError) {\n                throw new Error('XML parsing error');\n            }\n            \n            const nodes = new Map();\n            const ways = [];\n            const relations = [];\n            \n            // Parse nodes\n            xmlDoc.querySelectorAll('node').forEach(nodeEl => {\n                const id = nodeEl.getAttribute('id');\n                const lat = parseFloat(nodeEl.getAttribute('lat'));\n                const lon = parseFloat(nodeEl.getAttribute('lon'));\n                \n                const tags = {};\n                nodeEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                nodes.set(id, { id, lat, lon, tags });\n            });\n            \n            // Parse ways\n            xmlDoc.querySelectorAll('way').forEach(wayEl => {\n                const id = wayEl.getAttribute('id');\n                const ndRefs = [];\n                \n                wayEl.querySelectorAll('nd').forEach(nd => {\n                    ndRefs.push(nd.getAttribute('ref'));\n                });\n                \n                const tags = {};\n                wayEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                // Only include ways with highway tag (roads)\n                if (tags.highway) {\n                    ways.push({ id, ndRefs, tags });\n                }\n            });\n            \n            // Convert ways to GeoJSON LineStrings\n            const features = ways.map(way => {\n                const coordinates = way.ndRefs\n                    .map(ref => {\n                        const node = nodes.get(ref);\n                        if (node) {\n                            return [node.lon, node.lat];\n                        }\n                        return null;\n                    })\n                    .filter(coord => coord !== null);\n                \n                if (coordinates.length < 2) {\n                    return null; // Skip invalid ways\n                }\n                \n                return {\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        ...way.tags,\n                        osm_id: way.id\n                    }\n                };\n            }).filter(f => f !== null);\n            \n            return {\n                type: 'FeatureCollection',\n                features: features\n            };\n        } catch (error) {\n            console.error('Error parsing OSM XML:', error);\n            return { type: 'FeatureCollection', features: [] };\n        }\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    async previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer and OSM data layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer) && !layer._isOsmDataLayer) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n            \n            // Load OSM data for the area (async, will add to editableLayers when loaded)\n            this.loadOsmDataForPreview(sequence).then(() => {\n                // After OSM data loads, add it to editable layers\n                if (this.osmDataLayer) {\n                    this.osmDataLayer.eachLayer((layer) => {\n                        if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                            this.editableLayers.push(layer);\n                            layer.feature = layer.feature || {};\n                            layer._isOsmData = true; // Mark as OSM data\n                        }\n                    });\n                    console.log('OSM data layers added to editable layers. Total:', this.editableLayers.length);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing (GPS trace)\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n                layer._isGpsTrace = true; // Mark as GPS trace\n            });\n            \n            // Store OSM data layers for editing (if OSM data is loaded)\n            if (this.osmDataLayer) {\n                this.osmDataLayer.eachLayer((layer) => {\n                    if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                        this.editableLayers.push(layer);\n                        layer.feature = layer.feature || {};\n                        layer._isOsmData = true; // Mark as OSM data\n                    }\n                });\n            }\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker, 'GPS:', layer._isGpsTrace, 'OSM:', layer._isOsmData);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // Ensure OSM data layers are included in editable layers\n            if (this.osmDataLayer && this.osmDataLayer.eachLayer) {\n                let osmLayersAdded = 0;\n                this.osmDataLayer.eachLayer((layer) => {\n                    if ((layer instanceof L.Polyline || layer instanceof L.Polygon) && !layer._isOsmData) {\n                        // Check if already in editableLayers\n                        if (!this.editableLayers.includes(layer)) {\n                            this.editableLayers.push(layer);\n                            layer._isOsmData = true;\n                            osmLayersAdded++;\n                        }\n                    }\n                });\n                if (osmLayersAdded > 0) {\n                    console.log(`Added ${osmLayersAdded} OSM data layers to editable layers`);\n                }\n            }\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers (including OSM data)');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers in real-time during drag for visual feedback\n                                // Update marker positions directly (synchronously) so they move with the way\n                                if (layer._vertexMarkers && layer._vertexMarkers.length === newLatLngs.length) {\n                                    // Update existing markers directly for immediate visual feedback\n                                    newLatLngs.forEach((latlng, index) => {\n                                        if (layer._vertexMarkers[index]) {\n                                            let lat, lng;\n                                            if (latlng instanceof L.LatLng) {\n                                                lat = latlng.lat;\n                                                lng = latlng.lng;\n                                            } else if (Array.isArray(latlng)) {\n                                                lat = latlng[0];\n                                                lng = latlng[1];\n                                            } else {\n                                                lat = latlng.lat || latlng[0];\n                                                lng = latlng.lng || latlng[1];\n                                            }\n                                            layer._vertexMarkers[index].setLatLng([lat, lng]);\n                                        }\n                                    });\n                                } else {\n                                    // If marker count doesn't match, recreate markers (shouldn't happen during drag)\n                                    if (!layer._updatingMarkers) {\n                                        layer._updatingMarkers = true;\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    }\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    const newLatlng = e.target.getLatLng();\n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      },
      "filesAfter": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        this.osmDataLayer = null; // OSM data layer for preview\n        this.osmNodes = new Map(); // Store OSM nodes for snapping (key: node id, value: {lat, lon})\n        this.osmWays = []; // Store OSM ways for snapping reference\n        this.snapThreshold = 0.0001; // ~10 meters snapping threshold\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async loadOsmDataForPreview(sequence) {\n        try {\n            // Calculate bounding box\n            const bbox = this.calculateBoundingBox(sequence);\n            \n            // Remove existing OSM data layer if present\n            if (this.osmDataLayer) {\n                this.map.removeLayer(this.osmDataLayer);\n                this.osmDataLayer = null;\n            }\n            \n            // Create Overpass API query to get all ways and nodes in the bounding box\n            const overpassQuery = `\n                [out:xml][timeout:25];\n                (\n                  way[\"highway\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                  relation[\"type\"=\"route\"][\"route\"~\"^(bus|tram|train|subway|light_rail|trolleybus|ferry|monorail|aerialway|share_taxi|funicular)$\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                );\n                (._;>;);\n                out body;\n            `;\n            \n            // Fetch OSM data from Overpass API\n            const overpassUrl = 'https://overpass-api.de/api/interpreter';\n            console.log('Loading OSM data for preview...');\n            \n            const response = await fetch(overpassUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(overpassQuery)}`\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Overpass API error: ${response.status}`);\n            }\n            \n            const osmXml = await response.text();\n            \n            // Parse OSM XML and convert to GeoJSON\n            const osmGeoJson = this.parseOsmXmlToGeoJson(osmXml);\n            \n            if (osmGeoJson && osmGeoJson.features && osmGeoJson.features.length > 0) {\n                // Add OSM data as a layer with distinct styling (gray, thinner)\n                this.osmDataLayer = L.geoJSON(osmGeoJson, {\n                    style: (feature) => {\n                        // Style OSM data differently from GPS trace\n                        const highway = feature.properties?.highway;\n                        let color = '#888888'; // Default gray\n                        let weight = 2;\n                        \n                        // Color code by highway type\n                        if (highway === 'motorway' || highway === 'trunk') {\n                            color = '#ff6b6b';\n                            weight = 3;\n                        } else if (highway === 'primary') {\n                            color = '#ffa500';\n                            weight = 2.5;\n                        } else if (highway === 'secondary') {\n                            color = '#ffd700';\n                            weight = 2;\n                        } else if (highway === 'tertiary') {\n                            color = '#90ee90';\n                            weight = 2;\n                        } else if (highway === 'residential' || highway === 'unclassified') {\n                            color = '#c0c0c0';\n                            weight = 1.5;\n                        }\n                        \n                        return {\n                            color: color,\n                            weight: weight,\n                            opacity: 0.6,\n                            dashArray: '5, 5' // Dashed line to distinguish from GPS trace\n                        };\n                    },\n                    onEachFeature: (feature, layer) => {\n                        // Mark this layer as OSM data layer (read-only)\n                        layer._isOsmDataLayer = true;\n                        layer._isReadOnly = true; // Mark as read-only\n                        // Make layer non-interactive for editing (but still visible)\n                        if (layer.setStyle) {\n                            layer.setStyle({ interactive: false });\n                        }\n                        // Store original feature for reference\n                        layer.feature = feature;\n                    }\n                }).addTo(this.map);\n                \n                console.log(`Loaded ${osmGeoJson.features.length} OSM features for preview`);\n            } else {\n                console.log('No OSM data found in the area');\n            }\n        } catch (error) {\n            console.warn('Failed to load OSM data for preview:', error);\n            // Continue without OSM data - not critical\n        }\n    }\n\n    parseOsmXmlToGeoJson(osmXml) {\n        try {\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(osmXml, 'text/xml');\n            \n            // Check for parsing errors\n            const parserError = xmlDoc.querySelector('parsererror');\n            if (parserError) {\n                throw new Error('XML parsing error');\n            }\n            \n            const nodes = new Map();\n            const ways = [];\n            const relations = [];\n            \n            // Clear previous OSM data\n            this.osmNodes.clear();\n            this.osmWays = [];\n            \n            // Parse nodes\n            xmlDoc.querySelectorAll('node').forEach(nodeEl => {\n                const id = nodeEl.getAttribute('id');\n                const lat = parseFloat(nodeEl.getAttribute('lat'));\n                const lon = parseFloat(nodeEl.getAttribute('lon'));\n                \n                const tags = {};\n                nodeEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                nodes.set(id, { id, lat, lon, tags });\n                // Store in osmNodes for snapping\n                this.osmNodes.set(id, { lat, lon });\n            });\n            \n            // Parse ways\n            xmlDoc.querySelectorAll('way').forEach(wayEl => {\n                const id = wayEl.getAttribute('id');\n                const ndRefs = [];\n                \n                wayEl.querySelectorAll('nd').forEach(nd => {\n                    ndRefs.push(nd.getAttribute('ref'));\n                });\n                \n                const tags = {};\n                wayEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                // Only include ways with highway tag (roads)\n                if (tags.highway) {\n                    ways.push({ id, ndRefs, tags });\n                    // Store way coordinates for snapping reference\n                    const wayCoords = ndRefs\n                        .map(ref => {\n                            const node = nodes.get(ref);\n                            if (node) {\n                                return { lat: node.lat, lon: node.lon };\n                            }\n                            return null;\n                        })\n                        .filter(coord => coord !== null);\n                    if (wayCoords.length >= 2) {\n                        this.osmWays.push({ id, coordinates: wayCoords, tags });\n                    }\n                }\n            });\n            \n            // Convert ways to GeoJSON LineStrings\n            const features = ways.map(way => {\n                const coordinates = way.ndRefs\n                    .map(ref => {\n                        const node = nodes.get(ref);\n                        if (node) {\n                            return [node.lon, node.lat];\n                        }\n                        return null;\n                    })\n                    .filter(coord => coord !== null);\n                \n                if (coordinates.length < 2) {\n                    return null; // Skip invalid ways\n                }\n                \n                return {\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        ...way.tags,\n                        osm_id: way.id\n                    }\n                };\n            }).filter(f => f !== null);\n            \n            console.log(`Parsed ${this.osmNodes.size} OSM nodes and ${this.osmWays.length} OSM ways for snapping`);\n            \n            return {\n                type: 'FeatureCollection',\n                features: features\n            };\n        } catch (error) {\n            console.error('Error parsing OSM XML:', error);\n            return { type: 'FeatureCollection', features: [] };\n        }\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    async previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer and OSM data layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer) && !layer._isOsmDataLayer) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n            \n            // Load OSM data for the area (async, will add to editableLayers when loaded)\n            this.loadOsmDataForPreview(sequence).then(() => {\n                // After OSM data loads, add it to editable layers\n                if (this.osmDataLayer) {\n                    this.osmDataLayer.eachLayer((layer) => {\n                        if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                            this.editableLayers.push(layer);\n                            layer.feature = layer.feature || {};\n                            layer._isOsmData = true; // Mark as OSM data\n                        }\n                    });\n                    console.log('OSM data layers added to editable layers. Total:', this.editableLayers.length);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing (GPS trace)\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n                layer._isGpsTrace = true; // Mark as GPS trace\n            });\n            \n            // Store OSM data layers for editing (if OSM data is loaded)\n            if (this.osmDataLayer) {\n                this.osmDataLayer.eachLayer((layer) => {\n                    if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                        this.editableLayers.push(layer);\n                        layer.feature = layer.feature || {};\n                        layer._isOsmData = true; // Mark as OSM data\n                    }\n                });\n            }\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker, 'GPS:', layer._isGpsTrace, 'OSM:', layer._isOsmData);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // OSM data layers are NOT editable - they are read-only reference for snapping\n            // Remove any OSM layers that might have been added to editableLayers\n            this.editableLayers = this.editableLayers.filter(layer => !layer._isOsmDataLayer && !layer._isReadOnly);\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers (including OSM data)');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers in real-time during drag for visual feedback\n                                // Update marker positions directly (synchronously) so they move with the way\n                                if (layer._vertexMarkers && layer._vertexMarkers.length === newLatLngs.length) {\n                                    // Update existing markers directly for immediate visual feedback\n                                    newLatLngs.forEach((latlng, index) => {\n                                        if (layer._vertexMarkers[index]) {\n                                            let lat, lng;\n                                            if (latlng instanceof L.LatLng) {\n                                                lat = latlng.lat;\n                                                lng = latlng.lng;\n                                            } else if (Array.isArray(latlng)) {\n                                                lat = latlng[0];\n                                                lng = latlng[1];\n                                            } else {\n                                                lat = latlng.lat || latlng[0];\n                                                lng = latlng.lng || latlng[1];\n                                            }\n                                            layer._vertexMarkers[index].setLatLng([lat, lng]);\n                                        }\n                                    });\n                                } else {\n                                    // If marker count doesn't match, recreate markers (shouldn't happen during drag)\n                                    if (!layer._updatingMarkers) {\n                                        layer._updatingMarkers = true;\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    }\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    let newLatlng = e.target.getLatLng();\n                    \n                    // Only snap if this is a GPS trace layer (not OSM data)\n                    if (layer._isGpsTrace) {\n                        // Check for nearby OSM node to snap to\n                        const nearestOsmNode = this.findNearestOsmNode(newLatlng);\n                        if (nearestOsmNode) {\n                            // Snap to OSM node\n                            newLatlng = L.latLng(nearestOsmNode.lat, nearestOsmNode.lon);\n                            // Visual feedback: change marker color when snapping\n                            if (!marker._isSnapped) {\n                                marker._isSnapped = true;\n                                const icon = marker.getIcon();\n                                if (icon && icon.options) {\n                                    icon.options.html = '<div class=\"vertex-handle\" style=\"background: #00ff00; border-color: #ffffff;\"></div>';\n                                    marker.setIcon(icon);\n                                }\n                            }\n                        } else {\n                            // Not snapping - restore normal color\n                            if (marker._isSnapped) {\n                                marker._isSnapped = false;\n                                const icon = marker.getIcon();\n                                if (icon && icon.options) {\n                                    icon.options.html = '<div class=\"vertex-handle\"></div>';\n                                    marker.setIcon(icon);\n                                }\n                            }\n                        }\n                    }\n                    \n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      }
    },
    {
      "promptNumber": 5,
      "promptText": "i dont like the current merge function. maybe can make it such that the current OSM data can be edited as well?",
      "timestamp": "2025-12-16T18:22:43.660354",
      "filesBefore": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        this.osmDataLayer = null; // OSM data layer for preview\n        this.osmNodes = new Map(); // Store OSM nodes for snapping (key: node id, value: {lat, lon})\n        this.osmWays = []; // Store OSM ways for snapping reference\n        this.snapThreshold = 0.0001; // ~10 meters snapping threshold\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async loadOsmDataForPreview(sequence) {\n        try {\n            // Calculate bounding box\n            const bbox = this.calculateBoundingBox(sequence);\n            \n            // Remove existing OSM data layer if present\n            if (this.osmDataLayer) {\n                this.map.removeLayer(this.osmDataLayer);\n                this.osmDataLayer = null;\n            }\n            \n            // Create Overpass API query to get all ways and nodes in the bounding box\n            const overpassQuery = `\n                [out:xml][timeout:25];\n                (\n                  way[\"highway\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                  relation[\"type\"=\"route\"][\"route\"~\"^(bus|tram|train|subway|light_rail|trolleybus|ferry|monorail|aerialway|share_taxi|funicular)$\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                );\n                (._;>;);\n                out body;\n            `;\n            \n            // Fetch OSM data from Overpass API\n            const overpassUrl = 'https://overpass-api.de/api/interpreter';\n            console.log('Loading OSM data for preview...');\n            \n            const response = await fetch(overpassUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(overpassQuery)}`\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Overpass API error: ${response.status}`);\n            }\n            \n            const osmXml = await response.text();\n            \n            // Parse OSM XML and convert to GeoJSON\n            const osmGeoJson = this.parseOsmXmlToGeoJson(osmXml);\n            \n            if (osmGeoJson && osmGeoJson.features && osmGeoJson.features.length > 0) {\n                // Add OSM data as a layer with distinct styling (gray, thinner)\n                this.osmDataLayer = L.geoJSON(osmGeoJson, {\n                    style: (feature) => {\n                        // Style OSM data differently from GPS trace\n                        const highway = feature.properties?.highway;\n                        let color = '#888888'; // Default gray\n                        let weight = 2;\n                        \n                        // Color code by highway type\n                        if (highway === 'motorway' || highway === 'trunk') {\n                            color = '#ff6b6b';\n                            weight = 3;\n                        } else if (highway === 'primary') {\n                            color = '#ffa500';\n                            weight = 2.5;\n                        } else if (highway === 'secondary') {\n                            color = '#ffd700';\n                            weight = 2;\n                        } else if (highway === 'tertiary') {\n                            color = '#90ee90';\n                            weight = 2;\n                        } else if (highway === 'residential' || highway === 'unclassified') {\n                            color = '#c0c0c0';\n                            weight = 1.5;\n                        }\n                        \n                        return {\n                            color: color,\n                            weight: weight,\n                            opacity: 0.6,\n                            dashArray: '5, 5' // Dashed line to distinguish from GPS trace\n                        };\n                    },\n                    onEachFeature: (feature, layer) => {\n                        // Mark this layer as OSM data layer (read-only)\n                        layer._isOsmDataLayer = true;\n                        layer._isReadOnly = true; // Mark as read-only\n                        // Make layer non-interactive for editing (but still visible)\n                        if (layer.setStyle) {\n                            layer.setStyle({ interactive: false });\n                        }\n                        // Store original feature for reference\n                        layer.feature = feature;\n                    }\n                }).addTo(this.map);\n                \n                console.log(`Loaded ${osmGeoJson.features.length} OSM features for preview`);\n            } else {\n                console.log('No OSM data found in the area');\n            }\n        } catch (error) {\n            console.warn('Failed to load OSM data for preview:', error);\n            // Continue without OSM data - not critical\n        }\n    }\n\n    parseOsmXmlToGeoJson(osmXml) {\n        try {\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(osmXml, 'text/xml');\n            \n            // Check for parsing errors\n            const parserError = xmlDoc.querySelector('parsererror');\n            if (parserError) {\n                throw new Error('XML parsing error');\n            }\n            \n            const nodes = new Map();\n            const ways = [];\n            const relations = [];\n            \n            // Clear previous OSM data\n            this.osmNodes.clear();\n            this.osmWays = [];\n            \n            // Parse nodes\n            xmlDoc.querySelectorAll('node').forEach(nodeEl => {\n                const id = nodeEl.getAttribute('id');\n                const lat = parseFloat(nodeEl.getAttribute('lat'));\n                const lon = parseFloat(nodeEl.getAttribute('lon'));\n                \n                const tags = {};\n                nodeEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                nodes.set(id, { id, lat, lon, tags });\n                // Store in osmNodes for snapping\n                this.osmNodes.set(id, { lat, lon });\n            });\n            \n            // Parse ways\n            xmlDoc.querySelectorAll('way').forEach(wayEl => {\n                const id = wayEl.getAttribute('id');\n                const ndRefs = [];\n                \n                wayEl.querySelectorAll('nd').forEach(nd => {\n                    ndRefs.push(nd.getAttribute('ref'));\n                });\n                \n                const tags = {};\n                wayEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                // Only include ways with highway tag (roads)\n                if (tags.highway) {\n                    ways.push({ id, ndRefs, tags });\n                    // Store way coordinates for snapping reference\n                    const wayCoords = ndRefs\n                        .map(ref => {\n                            const node = nodes.get(ref);\n                            if (node) {\n                                return { lat: node.lat, lon: node.lon };\n                            }\n                            return null;\n                        })\n                        .filter(coord => coord !== null);\n                    if (wayCoords.length >= 2) {\n                        this.osmWays.push({ id, coordinates: wayCoords, tags });\n                    }\n                }\n            });\n            \n            // Convert ways to GeoJSON LineStrings\n            const features = ways.map(way => {\n                const coordinates = way.ndRefs\n                    .map(ref => {\n                        const node = nodes.get(ref);\n                        if (node) {\n                            return [node.lon, node.lat];\n                        }\n                        return null;\n                    })\n                    .filter(coord => coord !== null);\n                \n                if (coordinates.length < 2) {\n                    return null; // Skip invalid ways\n                }\n                \n                return {\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        ...way.tags,\n                        osm_id: way.id\n                    }\n                };\n            }).filter(f => f !== null);\n            \n            console.log(`Parsed ${this.osmNodes.size} OSM nodes and ${this.osmWays.length} OSM ways for snapping`);\n            \n            return {\n                type: 'FeatureCollection',\n                features: features\n            };\n        } catch (error) {\n            console.error('Error parsing OSM XML:', error);\n            return { type: 'FeatureCollection', features: [] };\n        }\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    async previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer and OSM data layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer) && !layer._isOsmDataLayer) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n            \n            // Load OSM data for the area (async, will add to editableLayers when loaded)\n            this.loadOsmDataForPreview(sequence).then(() => {\n                // After OSM data loads, add it to editable layers\n                if (this.osmDataLayer) {\n                    this.osmDataLayer.eachLayer((layer) => {\n                        if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                            this.editableLayers.push(layer);\n                            layer.feature = layer.feature || {};\n                            layer._isOsmData = true; // Mark as OSM data\n                        }\n                    });\n                    console.log('OSM data layers added to editable layers. Total:', this.editableLayers.length);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing (GPS trace)\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n                layer._isGpsTrace = true; // Mark as GPS trace\n            });\n            \n            // Store OSM data layers for editing (if OSM data is loaded)\n            if (this.osmDataLayer) {\n                this.osmDataLayer.eachLayer((layer) => {\n                    if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                        this.editableLayers.push(layer);\n                        layer.feature = layer.feature || {};\n                        layer._isOsmData = true; // Mark as OSM data\n                    }\n                });\n            }\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker, 'GPS:', layer._isGpsTrace, 'OSM:', layer._isOsmData);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // OSM data layers are NOT editable - they are read-only reference for snapping\n            // Remove any OSM layers that might have been added to editableLayers\n            this.editableLayers = this.editableLayers.filter(layer => !layer._isOsmDataLayer && !layer._isReadOnly);\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers (including OSM data)');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers in real-time during drag for visual feedback\n                                // Update marker positions directly (synchronously) so they move with the way\n                                if (layer._vertexMarkers && layer._vertexMarkers.length === newLatLngs.length) {\n                                    // Update existing markers directly for immediate visual feedback\n                                    newLatLngs.forEach((latlng, index) => {\n                                        if (layer._vertexMarkers[index]) {\n                                            let lat, lng;\n                                            if (latlng instanceof L.LatLng) {\n                                                lat = latlng.lat;\n                                                lng = latlng.lng;\n                                            } else if (Array.isArray(latlng)) {\n                                                lat = latlng[0];\n                                                lng = latlng[1];\n                                            } else {\n                                                lat = latlng.lat || latlng[0];\n                                                lng = latlng.lng || latlng[1];\n                                            }\n                                            layer._vertexMarkers[index].setLatLng([lat, lng]);\n                                        }\n                                    });\n                                } else {\n                                    // If marker count doesn't match, recreate markers (shouldn't happen during drag)\n                                    if (!layer._updatingMarkers) {\n                                        layer._updatingMarkers = true;\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    }\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    let newLatlng = e.target.getLatLng();\n                    \n                    // Only snap if this is a GPS trace layer (not OSM data)\n                    if (layer._isGpsTrace) {\n                        // Check for nearby OSM node to snap to\n                        const nearestOsmNode = this.findNearestOsmNode(newLatlng);\n                        if (nearestOsmNode) {\n                            // Snap to OSM node\n                            newLatlng = L.latLng(nearestOsmNode.lat, nearestOsmNode.lon);\n                            // Visual feedback: change marker color when snapping\n                            if (!marker._isSnapped) {\n                                marker._isSnapped = true;\n                                const icon = marker.getIcon();\n                                if (icon && icon.options) {\n                                    icon.options.html = '<div class=\"vertex-handle\" style=\"background: #00ff00; border-color: #ffffff;\"></div>';\n                                    marker.setIcon(icon);\n                                }\n                            }\n                        } else {\n                            // Not snapping - restore normal color\n                            if (marker._isSnapped) {\n                                marker._isSnapped = false;\n                                const icon = marker.getIcon();\n                                if (icon && icon.options) {\n                                    icon.options.html = '<div class=\"vertex-handle\"></div>';\n                                    marker.setIcon(icon);\n                                }\n                            }\n                        }\n                    }\n                    \n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Find nearest OSM node for snapping\n    findNearestOsmNode(latlng, threshold = null) {\n        if (!this.osmNodes || this.osmNodes.size === 0) {\n            return null;\n        }\n        \n        const thresholdDist = threshold || this.snapThreshold;\n        let nearestNode = null;\n        let minDistance = Infinity;\n        \n        const lat = latlng instanceof L.LatLng ? latlng.lat : latlng[0] || latlng.lat;\n        const lon = latlng instanceof L.LatLng ? latlng.lng : latlng[1] || latlng.lng;\n        \n        this.osmNodes.forEach((node, nodeId) => {\n            const dx = node.lon - lon;\n            const dy = node.lat - lat;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            \n            if (distance < minDistance && distance <= thresholdDist) {\n                minDistance = distance;\n                nearestNode = { lat: node.lat, lon: node.lon, id: nodeId, distance: distance };\n            }\n        });\n        \n        return nearestNode;\n    }\n    \n    // Helper: Calculate distance between two lat/lng points\n    calculateDistance(latlng1, latlng2) {\n        const lat1 = latlng1 instanceof L.LatLng ? latlng1.lat : latlng1[0] || latlng1.lat;\n        const lon1 = latlng1 instanceof L.LatLng ? latlng1.lng : latlng1[1] || latlng1.lng;\n        const lat2 = latlng2 instanceof L.LatLng ? latlng2.lat : latlng2[0] || latlng2.lat;\n        const lon2 = latlng2 instanceof L.LatLng ? latlng2.lng : latlng2[1] || latlng2.lng;\n        \n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    \n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      },
      "filesAfter": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        this.osmDataLayer = null; // OSM data layer for preview\n        this.osmNodes = new Map(); // Store OSM nodes for snapping (key: node id, value: {lat, lon})\n        this.osmWays = []; // Store OSM ways for snapping reference\n        this.snapThreshold = 0.0001; // ~10 meters snapping threshold\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async loadOsmDataForPreview(sequence) {\n        try {\n            // Calculate bounding box\n            const bbox = this.calculateBoundingBox(sequence);\n            \n            // Remove existing OSM data layer if present\n            if (this.osmDataLayer) {\n                this.map.removeLayer(this.osmDataLayer);\n                this.osmDataLayer = null;\n            }\n            \n            // Create Overpass API query to get all ways and nodes in the bounding box\n            const overpassQuery = `\n                [out:xml][timeout:25];\n                (\n                  way[\"highway\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                  relation[\"type\"=\"route\"][\"route\"~\"^(bus|tram|train|subway|light_rail|trolleybus|ferry|monorail|aerialway|share_taxi|funicular)$\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                );\n                (._;>;);\n                out body;\n            `;\n            \n            // Fetch OSM data from Overpass API\n            const overpassUrl = 'https://overpass-api.de/api/interpreter';\n            console.log('Loading OSM data for preview...');\n            \n            const response = await fetch(overpassUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(overpassQuery)}`\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Overpass API error: ${response.status}`);\n            }\n            \n            const osmXml = await response.text();\n            \n            // Parse OSM XML and convert to GeoJSON\n            const osmGeoJson = this.parseOsmXmlToGeoJson(osmXml);\n            \n            if (osmGeoJson && osmGeoJson.features && osmGeoJson.features.length > 0) {\n                // Add OSM data as a layer with distinct styling (gray, thinner)\n                this.osmDataLayer = L.geoJSON(osmGeoJson, {\n                    style: (feature) => {\n                        // Style OSM data differently from GPS trace\n                        const highway = feature.properties?.highway;\n                        let color = '#888888'; // Default gray\n                        let weight = 2;\n                        \n                        // Color code by highway type\n                        if (highway === 'motorway' || highway === 'trunk') {\n                            color = '#ff6b6b';\n                            weight = 3;\n                        } else if (highway === 'primary') {\n                            color = '#ffa500';\n                            weight = 2.5;\n                        } else if (highway === 'secondary') {\n                            color = '#ffd700';\n                            weight = 2;\n                        } else if (highway === 'tertiary') {\n                            color = '#90ee90';\n                            weight = 2;\n                        } else if (highway === 'residential' || highway === 'unclassified') {\n                            color = '#c0c0c0';\n                            weight = 1.5;\n                        }\n                        \n                        return {\n                            color: color,\n                            weight: weight,\n                            opacity: 0.6,\n                            dashArray: '5, 5' // Dashed line to distinguish from GPS trace\n                        };\n                    },\n                    onEachFeature: (feature, layer) => {\n                        // Mark this layer as OSM data layer (editable)\n                        layer._isOsmDataLayer = true;\n                        // Store original feature for reference\n                        layer.feature = feature;\n                        // OSM data is now editable, so keep it interactive\n                    }\n                }).addTo(this.map);\n                \n                console.log(`Loaded ${osmGeoJson.features.length} OSM features for preview`);\n            } else {\n                console.log('No OSM data found in the area');\n            }\n        } catch (error) {\n            console.warn('Failed to load OSM data for preview:', error);\n            // Continue without OSM data - not critical\n        }\n    }\n\n    parseOsmXmlToGeoJson(osmXml) {\n        try {\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(osmXml, 'text/xml');\n            \n            // Check for parsing errors\n            const parserError = xmlDoc.querySelector('parsererror');\n            if (parserError) {\n                throw new Error('XML parsing error');\n            }\n            \n            const nodes = new Map();\n            const ways = [];\n            const relations = [];\n            \n            // Clear previous OSM data\n            this.osmNodes.clear();\n            this.osmWays = [];\n            \n            // Parse nodes\n            xmlDoc.querySelectorAll('node').forEach(nodeEl => {\n                const id = nodeEl.getAttribute('id');\n                const lat = parseFloat(nodeEl.getAttribute('lat'));\n                const lon = parseFloat(nodeEl.getAttribute('lon'));\n                \n                const tags = {};\n                nodeEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                nodes.set(id, { id, lat, lon, tags });\n                // Store in osmNodes for snapping\n                this.osmNodes.set(id, { lat, lon });\n            });\n            \n            // Parse ways\n            xmlDoc.querySelectorAll('way').forEach(wayEl => {\n                const id = wayEl.getAttribute('id');\n                const ndRefs = [];\n                \n                wayEl.querySelectorAll('nd').forEach(nd => {\n                    ndRefs.push(nd.getAttribute('ref'));\n                });\n                \n                const tags = {};\n                wayEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                // Only include ways with highway tag (roads)\n                if (tags.highway) {\n                    ways.push({ id, ndRefs, tags });\n                    // Store way coordinates for snapping reference\n                    const wayCoords = ndRefs\n                        .map(ref => {\n                            const node = nodes.get(ref);\n                            if (node) {\n                                return { lat: node.lat, lon: node.lon };\n                            }\n                            return null;\n                        })\n                        .filter(coord => coord !== null);\n                    if (wayCoords.length >= 2) {\n                        this.osmWays.push({ id, coordinates: wayCoords, tags });\n                    }\n                }\n            });\n            \n            // Convert ways to GeoJSON LineStrings\n            const features = ways.map(way => {\n                const coordinates = way.ndRefs\n                    .map(ref => {\n                        const node = nodes.get(ref);\n                        if (node) {\n                            return [node.lon, node.lat];\n                        }\n                        return null;\n                    })\n                    .filter(coord => coord !== null);\n                \n                if (coordinates.length < 2) {\n                    return null; // Skip invalid ways\n                }\n                \n                return {\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        ...way.tags,\n                        osm_id: way.id\n                    }\n                };\n            }).filter(f => f !== null);\n            \n            console.log(`Parsed ${this.osmNodes.size} OSM nodes and ${this.osmWays.length} OSM ways for snapping`);\n            \n            return {\n                type: 'FeatureCollection',\n                features: features\n            };\n        } catch (error) {\n            console.error('Error parsing OSM XML:', error);\n            return { type: 'FeatureCollection', features: [] };\n        }\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    async previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer and OSM data layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer) && !layer._isOsmDataLayer) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n            \n            // Load OSM data for the area (async, will add to editableLayers when loaded)\n            this.loadOsmDataForPreview(sequence).then(() => {\n                // After OSM data loads, add it to editable layers\n                if (this.osmDataLayer) {\n                    this.osmDataLayer.eachLayer((layer) => {\n                        if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                            this.editableLayers.push(layer);\n                            layer.feature = layer.feature || {};\n                            layer._isOsmData = true; // Mark as OSM data\n                        }\n                    });\n                    console.log('OSM data layers added to editable layers. Total:', this.editableLayers.length);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing (GPS trace)\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n                layer._isGpsTrace = true; // Mark as GPS trace\n            });\n            \n            // Store OSM data layers for editing (if OSM data is loaded)\n            if (this.osmDataLayer) {\n                this.osmDataLayer.eachLayer((layer) => {\n                    if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                        this.editableLayers.push(layer);\n                        layer.feature = layer.feature || {};\n                        layer._isOsmData = true; // Mark as OSM data\n                    }\n                });\n            }\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker, 'GPS:', layer._isGpsTrace, 'OSM:', layer._isOsmData);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // Ensure OSM data layers are included in editable layers (they are now editable)\n            if (this.osmDataLayer && this.osmDataLayer.eachLayer) {\n                this.osmDataLayer.eachLayer((layer) => {\n                    if ((layer instanceof L.Polyline || layer instanceof L.Polygon) && !this.editableLayers.includes(layer)) {\n                        this.editableLayers.push(layer);\n                        layer.feature = layer.feature || {};\n                        layer._isOsmData = true; // Mark as OSM data (but editable)\n                    }\n                });\n            }\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers (including OSM data)');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers in real-time during drag for visual feedback\n                                // Update marker positions directly (synchronously) so they move with the way\n                                if (layer._vertexMarkers && layer._vertexMarkers.length === newLatLngs.length) {\n                                    // Update existing markers directly for immediate visual feedback\n                                    newLatLngs.forEach((latlng, index) => {\n                                        if (layer._vertexMarkers[index]) {\n                                            let lat, lng;\n                                            if (latlng instanceof L.LatLng) {\n                                                lat = latlng.lat;\n                                                lng = latlng.lng;\n                                            } else if (Array.isArray(latlng)) {\n                                                lat = latlng[0];\n                                                lng = latlng[1];\n                                            } else {\n                                                lat = latlng.lat || latlng[0];\n                                                lng = latlng.lng || latlng[1];\n                                            }\n                                            layer._vertexMarkers[index].setLatLng([lat, lng]);\n                                        }\n                                    });\n                                } else {\n                                    // If marker count doesn't match, recreate markers (shouldn't happen during drag)\n                                    if (!layer._updatingMarkers) {\n                                        layer._updatingMarkers = true;\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    }\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    let newLatlng = e.target.getLatLng();\n                    \n                    // Only snap if this is a GPS trace layer (not OSM data)\n                    if (layer._isGpsTrace) {\n                        // Check for nearby OSM node to snap to\n                        const nearestOsmNode = this.findNearestOsmNode(newLatlng);\n                        if (nearestOsmNode) {\n                            // Snap to OSM node\n                            newLatlng = L.latLng(nearestOsmNode.lat, nearestOsmNode.lon);\n                            // Visual feedback: change marker color when snapping\n                            if (!marker._isSnapped) {\n                                marker._isSnapped = true;\n                                const icon = marker.getIcon();\n                                if (icon && icon.options) {\n                                    icon.options.html = '<div class=\"vertex-handle\" style=\"background: #00ff00; border-color: #ffffff;\"></div>';\n                                    marker.setIcon(icon);\n                                }\n                            }\n                        } else {\n                            // Not snapping - restore normal color\n                            if (marker._isSnapped) {\n                                marker._isSnapped = false;\n                                const icon = marker.getIcon();\n                                if (icon && icon.options) {\n                                    icon.options.html = '<div class=\"vertex-handle\"></div>';\n                                    marker.setIcon(icon);\n                                }\n                            }\n                        }\n                    }\n                    \n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Find nearest OSM node for snapping\n    findNearestOsmNode(latlng, threshold = null) {\n        if (!this.osmNodes || this.osmNodes.size === 0) {\n            return null;\n        }\n        \n        const thresholdDist = threshold || this.snapThreshold;\n        let nearestNode = null;\n        let minDistance = Infinity;\n        \n        const lat = latlng instanceof L.LatLng ? latlng.lat : latlng[0] || latlng.lat;\n        const lon = latlng instanceof L.LatLng ? latlng.lng : latlng[1] || latlng.lng;\n        \n        this.osmNodes.forEach((node, nodeId) => {\n            const dx = node.lon - lon;\n            const dy = node.lat - lat;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            \n            if (distance < minDistance && distance <= thresholdDist) {\n                minDistance = distance;\n                nearestNode = { lat: node.lat, lon: node.lon, id: nodeId, distance: distance };\n            }\n        });\n        \n        return nearestNode;\n    }\n    \n    // Helper: Calculate distance between two lat/lng points\n    calculateDistance(latlng1, latlng2) {\n        const lat1 = latlng1 instanceof L.LatLng ? latlng1.lat : latlng1[0] || latlng1.lat;\n        const lon1 = latlng1 instanceof L.LatLng ? latlng1.lng : latlng1[1] || latlng1.lng;\n        const lat2 = latlng2 instanceof L.LatLng ? latlng2.lat : latlng2[0] || latlng2.lat;\n        const lon2 = latlng2 instanceof L.LatLng ? latlng2.lng : latlng2[1] || latlng2.lng;\n        \n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    \n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      }
    },
    {
      "promptNumber": 6,
      "promptText": "lets not be confused. the simplify geometry feature shld only be for the blue ways not for the exsisting ways. also, how do i merge the nodes?",
      "timestamp": "2025-12-17T17:46:43.165705",
      "filesBefore": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        this.osmDataLayer = null; // OSM data layer for preview\n        this.osmNodes = new Map(); // Store OSM nodes for snapping (key: node id, value: {lat, lon})\n        this.osmWays = []; // Store OSM ways for snapping reference\n        this.snapThreshold = 0.0001; // ~10 meters snapping threshold\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async loadOsmDataForPreview(sequence) {\n        try {\n            // Calculate bounding box\n            const bbox = this.calculateBoundingBox(sequence);\n            \n            // Remove existing OSM data layer if present\n            if (this.osmDataLayer) {\n                this.map.removeLayer(this.osmDataLayer);\n                this.osmDataLayer = null;\n            }\n            \n            // Create Overpass API query to get all ways and nodes in the bounding box\n            const overpassQuery = `\n                [out:xml][timeout:25];\n                (\n                  way[\"highway\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                  relation[\"type\"=\"route\"][\"route\"~\"^(bus|tram|train|subway|light_rail|trolleybus|ferry|monorail|aerialway|share_taxi|funicular)$\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                );\n                (._;>;);\n                out body;\n            `;\n            \n            // Fetch OSM data from Overpass API\n            const overpassUrl = 'https://overpass-api.de/api/interpreter';\n            console.log('Loading OSM data for preview...');\n            \n            const response = await fetch(overpassUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(overpassQuery)}`\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Overpass API error: ${response.status}`);\n            }\n            \n            const osmXml = await response.text();\n            \n            // Parse OSM XML and convert to GeoJSON\n            const osmGeoJson = this.parseOsmXmlToGeoJson(osmXml);\n            \n            if (osmGeoJson && osmGeoJson.features && osmGeoJson.features.length > 0) {\n                // Add OSM data as a layer with distinct styling (gray, thinner)\n                this.osmDataLayer = L.geoJSON(osmGeoJson, {\n                    style: (feature) => {\n                        // Style OSM data differently from GPS trace\n                        const highway = feature.properties?.highway;\n                        let color = '#888888'; // Default gray\n                        let weight = 2;\n                        \n                        // Color code by highway type\n                        if (highway === 'motorway' || highway === 'trunk') {\n                            color = '#ff6b6b';\n                            weight = 3;\n                        } else if (highway === 'primary') {\n                            color = '#ffa500';\n                            weight = 2.5;\n                        } else if (highway === 'secondary') {\n                            color = '#ffd700';\n                            weight = 2;\n                        } else if (highway === 'tertiary') {\n                            color = '#90ee90';\n                            weight = 2;\n                        } else if (highway === 'residential' || highway === 'unclassified') {\n                            color = '#c0c0c0';\n                            weight = 1.5;\n                        }\n                        \n                        return {\n                            color: color,\n                            weight: weight,\n                            opacity: 0.6,\n                            dashArray: '5, 5' // Dashed line to distinguish from GPS trace\n                        };\n                    },\n                    onEachFeature: (feature, layer) => {\n                        // Mark this layer as OSM data layer (editable)\n                        layer._isOsmDataLayer = true;\n                        // Store original feature for reference\n                        layer.feature = feature;\n                        // OSM data is now editable, so keep it interactive\n                    }\n                }).addTo(this.map);\n                \n                console.log(`Loaded ${osmGeoJson.features.length} OSM features for preview`);\n            } else {\n                console.log('No OSM data found in the area');\n            }\n        } catch (error) {\n            console.warn('Failed to load OSM data for preview:', error);\n            // Continue without OSM data - not critical\n        }\n    }\n\n    parseOsmXmlToGeoJson(osmXml) {\n        try {\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(osmXml, 'text/xml');\n            \n            // Check for parsing errors\n            const parserError = xmlDoc.querySelector('parsererror');\n            if (parserError) {\n                throw new Error('XML parsing error');\n            }\n            \n            const nodes = new Map();\n            const ways = [];\n            const relations = [];\n            \n            // Clear previous OSM data\n            this.osmNodes.clear();\n            this.osmWays = [];\n            \n            // Parse nodes\n            xmlDoc.querySelectorAll('node').forEach(nodeEl => {\n                const id = nodeEl.getAttribute('id');\n                const lat = parseFloat(nodeEl.getAttribute('lat'));\n                const lon = parseFloat(nodeEl.getAttribute('lon'));\n                \n                const tags = {};\n                nodeEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                nodes.set(id, { id, lat, lon, tags });\n                // Store in osmNodes for snapping\n                this.osmNodes.set(id, { lat, lon });\n            });\n            \n            // Parse ways\n            xmlDoc.querySelectorAll('way').forEach(wayEl => {\n                const id = wayEl.getAttribute('id');\n                const ndRefs = [];\n                \n                wayEl.querySelectorAll('nd').forEach(nd => {\n                    ndRefs.push(nd.getAttribute('ref'));\n                });\n                \n                const tags = {};\n                wayEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                // Only include ways with highway tag (roads)\n                if (tags.highway) {\n                    ways.push({ id, ndRefs, tags });\n                    // Store way coordinates for snapping reference\n                    const wayCoords = ndRefs\n                        .map(ref => {\n                            const node = nodes.get(ref);\n                            if (node) {\n                                return { lat: node.lat, lon: node.lon };\n                            }\n                            return null;\n                        })\n                        .filter(coord => coord !== null);\n                    if (wayCoords.length >= 2) {\n                        this.osmWays.push({ id, coordinates: wayCoords, tags });\n                    }\n                }\n            });\n            \n            // Convert ways to GeoJSON LineStrings\n            const features = ways.map(way => {\n                const coordinates = way.ndRefs\n                    .map(ref => {\n                        const node = nodes.get(ref);\n                        if (node) {\n                            return [node.lon, node.lat];\n                        }\n                        return null;\n                    })\n                    .filter(coord => coord !== null);\n                \n                if (coordinates.length < 2) {\n                    return null; // Skip invalid ways\n                }\n                \n                return {\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        ...way.tags,\n                        osm_id: way.id\n                    }\n                };\n            }).filter(f => f !== null);\n            \n            console.log(`Parsed ${this.osmNodes.size} OSM nodes and ${this.osmWays.length} OSM ways for snapping`);\n            \n            return {\n                type: 'FeatureCollection',\n                features: features\n            };\n        } catch (error) {\n            console.error('Error parsing OSM XML:', error);\n            return { type: 'FeatureCollection', features: [] };\n        }\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    async previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer and OSM data layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer) && !layer._isOsmDataLayer) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n            \n            // Load OSM data for the area (async, will add to editableLayers when loaded)\n            this.loadOsmDataForPreview(sequence).then(() => {\n                // After OSM data loads, add it to editable layers\n                if (this.osmDataLayer) {\n                    this.osmDataLayer.eachLayer((layer) => {\n                        if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                            this.editableLayers.push(layer);\n                            layer.feature = layer.feature || {};\n                            layer._isOsmData = true; // Mark as OSM data\n                        }\n                    });\n                    console.log('OSM data layers added to editable layers. Total:', this.editableLayers.length);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing (GPS trace)\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n                layer._isGpsTrace = true; // Mark as GPS trace\n            });\n            \n            // Store OSM data layers for editing (if OSM data is loaded)\n            if (this.osmDataLayer) {\n                this.osmDataLayer.eachLayer((layer) => {\n                    if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                        this.editableLayers.push(layer);\n                        layer.feature = layer.feature || {};\n                        layer._isOsmData = true; // Mark as OSM data\n                    }\n                });\n            }\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker, 'GPS:', layer._isGpsTrace, 'OSM:', layer._isOsmData);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // Ensure OSM data layers are included in editable layers (they are now editable)\n            if (this.osmDataLayer && this.osmDataLayer.eachLayer) {\n                this.osmDataLayer.eachLayer((layer) => {\n                    if ((layer instanceof L.Polyline || layer instanceof L.Polygon) && !this.editableLayers.includes(layer)) {\n                        this.editableLayers.push(layer);\n                        layer.feature = layer.feature || {};\n                        layer._isOsmData = true; // Mark as OSM data (but editable)\n                    }\n                });\n            }\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers (including OSM data)');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers in real-time during drag for visual feedback\n                                // Update marker positions directly (synchronously) so they move with the way\n                                if (layer._vertexMarkers && layer._vertexMarkers.length === newLatLngs.length) {\n                                    // Update existing markers directly for immediate visual feedback\n                                    newLatLngs.forEach((latlng, index) => {\n                                        if (layer._vertexMarkers[index]) {\n                                            let lat, lng;\n                                            if (latlng instanceof L.LatLng) {\n                                                lat = latlng.lat;\n                                                lng = latlng.lng;\n                                            } else if (Array.isArray(latlng)) {\n                                                lat = latlng[0];\n                                                lng = latlng[1];\n                                            } else {\n                                                lat = latlng.lat || latlng[0];\n                                                lng = latlng.lng || latlng[1];\n                                            }\n                                            layer._vertexMarkers[index].setLatLng([lat, lng]);\n                                        }\n                                    });\n                                } else {\n                                    // If marker count doesn't match, recreate markers (shouldn't happen during drag)\n                                    if (!layer._updatingMarkers) {\n                                        layer._updatingMarkers = true;\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    }\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    const newLatlng = e.target.getLatLng();\n                    \n                    // OSM data is now editable, so no automatic snapping\n                    // Both GPS trace and OSM data can be edited independently\n                    \n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Find nearest OSM node for snapping\n    findNearestOsmNode(latlng, threshold = null) {\n        if (!this.osmNodes || this.osmNodes.size === 0) {\n            return null;\n        }\n        \n        const thresholdDist = threshold || this.snapThreshold;\n        let nearestNode = null;\n        let minDistance = Infinity;\n        \n        const lat = latlng instanceof L.LatLng ? latlng.lat : latlng[0] || latlng.lat;\n        const lon = latlng instanceof L.LatLng ? latlng.lng : latlng[1] || latlng.lng;\n        \n        this.osmNodes.forEach((node, nodeId) => {\n            const dx = node.lon - lon;\n            const dy = node.lat - lat;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            \n            if (distance < minDistance && distance <= thresholdDist) {\n                minDistance = distance;\n                nearestNode = { lat: node.lat, lon: node.lon, id: nodeId, distance: distance };\n            }\n        });\n        \n        return nearestNode;\n    }\n    \n    // Helper: Calculate distance between two lat/lng points\n    calculateDistance(latlng1, latlng2) {\n        const lat1 = latlng1 instanceof L.LatLng ? latlng1.lat : latlng1[0] || latlng1.lat;\n        const lon1 = latlng1 instanceof L.LatLng ? latlng1.lng : latlng1[1] || latlng1.lng;\n        const lat2 = latlng2 instanceof L.LatLng ? latlng2.lat : latlng2[0] || latlng2.lat;\n        const lon2 = latlng2 instanceof L.LatLng ? latlng2.lng : latlng2[1] || latlng2.lng;\n        \n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    \n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      },
      "filesAfter": {
        "app.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.currentIndex = 0;\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentView = 'all'; // 'all', 'active', 'done', or 'skipped'\n        this.navigatingToSequenceId = null; // Track sequence we're navigating to for highlighting\n        this.allTasksSearchTerm = ''; // Track search term for \"All Tasks\" tab\n        this.previewEditMode = false; // Track if preview is in edit mode\n        this.originalPreviewFeatures = null; // Store original features for revert\n        this.editableLayers = []; // Track editable layers\n        this.osmDataLayer = null; // OSM data layer for preview\n        this.osmNodes = new Map(); // Store OSM nodes for snapping (key: node id, value: {lat, lon})\n        this.osmWays = []; // Store OSM ways for snapping reference\n        this.snapThreshold = 0.0001; // ~10 meters snapping threshold\n        \n        // Undo/Redo history\n        this.editHistory = []; // Array of geometry states\n        this.currentHistoryIndex = -1; // Current position in history (-1 means no history)\n        this.maxHistorySize = 50; // Maximum number of history states to keep\n        \n        this.init();\n    }\n\n    async init() {\n        // Initialize IndexedDB\n        try {\n            await storageManager.init();\n        } catch (error) {\n            console.error('Failed to initialize IndexedDB:', error);\n        }\n        \n        this.initializeEventListeners();\n        await this.loadFromStorage();\n    }\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('fileInput');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n\n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.showPrevious());\n        }\n\n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.showNext());\n        }\n    }\n\n    async handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        const results = await Promise.allSettled(promises);\n        const newFeatures = [];\n        const errors = [];\n        let loadedCount = 0;\n\n        results.forEach((result) => {\n            if (result.status === 'fulfilled') {\n                newFeatures.push(...result.value.geojson.features);\n                loadedCount++;\n            } else {\n                errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n            }\n        });\n\n        if (newFeatures.length === 0) {\n            if (fileInfo) {\n                fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n            }\n            return;\n        }\n\n        // Merge with existing cached data instead of replacing\n        const existingFeatures = this.geojsonData?.features || [];\n        const allFeatures = [...existingFeatures, ...newFeatures];\n\n        // Combine all features into one GeoJSON\n        const combinedGeoJSON = {\n            type: 'FeatureCollection',\n            features: allFeatures\n        };\n\n        this.geojsonData = combinedGeoJSON;\n        \n        // Process with progress indicator for large datasets\n        if (allFeatures.length > 50) {\n            if (fileInfo) {\n                fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n            }\n            await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing: ${progress}%...`;\n                }\n            });\n            } else {\n                await this.processGeoJSON(combinedGeoJSON);\n            }\n        \n        // Save to IndexedDB\n        await this.saveToStorage();\n        \n        const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n        const totalFeatures = allFeatures.length;\n        const addedCount = newFeatures.length;\n        const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n        \n        if (fileInfo) {\n            fileInfo.textContent = fileInfoText;\n        }\n    }\n\n    async processGeoJSON(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            throw new Error('Invalid GeoJSON: missing features array');\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId);\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus !== undefined ? existingStatus : '', // blank = active\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID (numeric if possible, otherwise alphabetical)\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n\n        this.geojsonData = geojson;\n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status !== undefined) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId);\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus !== undefined ? existingStatus : '',\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        this.geojsonData = geojson;\n        \n        // Reset to first item in current view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        await this.saveToStorage();\n        this.renderCurrentTask();\n        this.updateSummary();\n    }\n\n    calculateStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    getAllSequences() {\n        // Return all sequences regardless of status (master data source)\n        return this.sequences;\n    }\n\n    getActiveSequences() {\n        // Return sequences that are not skipped or done (blank status = active)\n        return this.sequences.filter(seq => !seq.status || seq.status === '');\n    }\n\n    getDoneSequences() {\n        // Return sequences that are marked as done\n        return this.sequences.filter(seq => seq.status === 'done');\n    }\n\n    getSkippedSequences() {\n        // Return sequences that are marked as skipped\n        return this.sequences.filter(seq => seq.status === 'skipped');\n    }\n\n    getCurrentViewSequences() {\n        // Return sequences based on current view\n        switch(this.currentView) {\n            case 'all':\n                return this.getAllSequences();\n            case 'done':\n                return this.getDoneSequences();\n            case 'skipped':\n                return this.getSkippedSequences();\n            case 'active':\n            default:\n                return this.getActiveSequences();\n        }\n    }\n\n    switchView(view, targetSequenceId = null) {\n        this.currentView = view;\n        \n        // Update tab buttons\n        document.querySelectorAll('.tab-btn').forEach(btn => {\n            if (btn.dataset.view === view) {\n                btn.classList.add('active');\n            } else {\n                btn.classList.remove('active');\n            }\n        });\n        \n        // If targetSequenceId is provided, navigate to that specific sequence\n        if (targetSequenceId !== null) {\n            const targetIndex = this.sequences.findIndex(seq => seq.id === targetSequenceId);\n            if (targetIndex >= 0) {\n                this.currentIndex = targetIndex;\n                this.renderCurrentTask();\n                return;\n            }\n        }\n        \n        // Reset to first item in the new view\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length > 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n        } else {\n            this.currentIndex = 0;\n        }\n        \n        this.renderCurrentTask();\n    }\n\n    navigateToSequence(sequenceId) {\n        // Find the sequence in our data\n        const sequence = this.sequences.find(seq => seq.id === sequenceId);\n        if (!sequence) {\n            console.error('Sequence not found:', sequenceId);\n            return;\n        }\n\n        // Set flag to indicate we're navigating to this sequence (for highlighting)\n        this.navigatingToSequenceId = sequenceId;\n\n        // Determine which tab this sequence belongs to based on status\n        let targetView = 'active'; // default to active\n        if (sequence.status === 'done') {\n            targetView = 'done';\n        } else if (sequence.status === 'skipped') {\n            targetView = 'skipped';\n        } else {\n            targetView = 'active';\n        }\n\n        // Switch to the appropriate tab and navigate to the sequence\n        this.switchView(targetView, sequenceId);\n    }\n\n    renderCurrentTask() {\n        // Route to appropriate render method based on view\n        switch(this.currentView) {\n            case 'all':\n                this.renderAllTasksView();\n                break;\n            case 'skipped':\n            case 'done':\n                this.renderSimpleListView();\n                break;\n            case 'active':\n            default:\n                this.renderDetailedView();\n                break;\n        }\n    }\n\n    renderAllTasksView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No tasks found. Upload a file to begin.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for \"All Tasks\" - show full list\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n\n        // Filter sequences based on search term\n        const searchTerm = this.allTasksSearchTerm.toLowerCase().trim();\n        const filteredSequences = searchTerm \n            ? allSequences.filter(seq => String(seq.id).toLowerCase().includes(searchTerm))\n            : allSequences;\n\n        if (taskCounter) {\n            if (searchTerm) {\n                taskCounter.textContent = `Showing ${filteredSequences.length} of ${allSequences.length} sequences`;\n            } else {\n                taskCounter.textContent = `Total: ${allSequences.length} sequences`;\n            }\n        }\n\n        // Render simple list of all sequence IDs (clickable)\n        const sequenceList = filteredSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\").replace(/\"/g, \"&quot;\");\n            return `<div class=\"sequence-id-item clickable\" data-sequence-id=\"${escapedId}\" onclick=\"taskManager.navigateToSequence('${escapedId}')\">${seq.id}</div>`;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"all-tasks-list\">\n                <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;\">\n                    <h4>All Sequence IDs (${allSequences.length} total)</h4>\n                    <div style=\"display: flex; gap: 10px; align-items: center; flex-wrap: wrap;\">\n                        <div style=\"position: relative; flex: 1; min-width: 200px;\">\n                            <input \n                                type=\"text\" \n                                id=\"allTasksSearchInput\" \n                                class=\"search-input\" \n                                placeholder=\"ðŸ” Search sequence ID...\" \n                                value=\"${this.allTasksSearchTerm}\"\n                                oninput=\"taskManager.handleAllTasksSearch(this.value)\"\n                            />\n                        </div>\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportAllToCSV()\" style=\"white-space: nowrap;\">\n                            ðŸ“Š Export to CSV\n                        </button>\n                    </div>\n                </div>\n                ${filteredSequences.length === 0 && searchTerm ? `\n                    <div class=\"empty-state\">\n                        <p>No sequences found matching \"${this.allTasksSearchTerm}\"</p>\n                    </div>\n                ` : `\n                    <div class=\"sequence-list\">\n                        ${sequenceList}\n                    </div>\n                `}\n            </div>\n        `;\n    }\n\n    handleAllTasksSearch(searchTerm) {\n        this.allTasksSearchTerm = searchTerm;\n        \n        // Get the search input element to preserve focus and cursor position\n        const searchInput = document.getElementById('allTasksSearchInput');\n        const wasFocused = document.activeElement === searchInput;\n        const cursorPosition = searchInput ? searchInput.selectionStart : null;\n        \n        // Re-render the view\n        this.renderAllTasksView();\n        \n        // Restore focus and cursor position if it was focused\n        if (wasFocused) {\n            // Use requestAnimationFrame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                const newSearchInput = document.getElementById('allTasksSearchInput');\n                if (newSearchInput) {\n                    newSearchInput.focus();\n                    // Set cursor position, accounting for the new value length\n                    const newCursorPos = cursorPosition !== null \n                        ? Math.min(cursorPosition, newSearchInput.value.length) \n                        : newSearchInput.value.length;\n                    newSearchInput.setSelectionRange(newCursorPos, newCursorPos);\n                }\n            });\n        }\n    }\n\n    renderSimpleListView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getCurrentViewSequences();\n        \n        if (viewSequences.length === 0) {\n            const viewName = this.currentView === 'done' ? 'done' : 'skipped';\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No ${viewName} tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Hide navigation for list view\n        if (prevBtn) prevBtn.style.display = 'none';\n        if (nextBtn) nextBtn.style.display = 'none';\n        if (taskCounter) taskCounter.textContent = `${viewSequences.length} ${this.currentView} sequence(s)`;\n\n        // Render full list: Sequence ID + Status dropdown for each\n        const viewName = this.currentView === 'done' ? 'Done' : 'Skipped';\n        const sequenceList = viewSequences.map(seq => {\n            const escapedId = String(seq.id).replace(/'/g, \"\\\\'\");\n            const isTarget = this.navigatingToSequenceId && String(seq.id) === String(this.navigatingToSequenceId);\n            return `\n                <div class=\"sequence-item-with-status\" data-sequence-id=\"${seq.id}\" ${isTarget ? 'data-highlight=\"true\"' : ''}>\n                    <div class=\"sequence-id-display\">${seq.id}</div>\n                    <select class=\"status-dropdown-inline\" data-sequence-id=\"${seq.id}\" onchange=\"taskManager.updateStatus('${escapedId}', this.value)\">\n                        <option value=\"\" ${!seq.status || seq.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${seq.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${seq.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n            `;\n        }).join('');\n\n        taskDisplay.innerHTML = `\n            <div class=\"simple-list-view\">\n                <h4>${viewName} Sequences (${viewSequences.length} total)</h4>\n                <div class=\"sequence-list-with-status\">\n                    ${sequenceList}\n                </div>\n            </div>\n        `;\n\n        // If we navigated here via navigateToSequence, scroll to and highlight the target\n        if (this.navigatingToSequenceId) {\n            const targetSequenceId = this.navigatingToSequenceId;\n            setTimeout(() => {\n                const targetElement = document.querySelector(`[data-sequence-id=\"${targetSequenceId}\"]`);\n                if (targetElement) {\n                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n                    targetElement.classList.add('highlighted');\n                    setTimeout(() => {\n                        targetElement.classList.remove('highlighted');\n                        this.navigatingToSequenceId = null; // Clear the flag after highlighting\n                    }, 2000);\n                } else {\n                    this.navigatingToSequenceId = null; // Clear flag if element not found\n                }\n            }, 100);\n        }\n    }\n\n    renderDetailedView() {\n        const taskDisplay = document.getElementById('taskDisplay');\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const taskCounter = document.getElementById('taskCounter');\n\n        const viewSequences = this.getActiveSequences();\n        \n        if (viewSequences.length === 0) {\n            taskDisplay.innerHTML = `\n                <div class=\"empty-state\">\n                    <p>No active tasks found.</p>\n                </div>\n            `;\n            if (prevBtn) prevBtn.disabled = true;\n            if (nextBtn) nextBtn.disabled = true;\n            if (taskCounter) taskCounter.textContent = '';\n            return;\n        }\n\n        // Show navigation\n        if (prevBtn) {\n            prevBtn.style.display = 'inline-block';\n            prevBtn.disabled = false;\n        }\n        if (nextBtn) {\n            nextBtn.style.display = 'inline-block';\n            nextBtn.disabled = false;\n        }\n\n        // Ensure current index is valid\n        const currentSequence = this.sequences[this.currentIndex];\n        let currentViewIndex = viewSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentViewIndex < 0) {\n            const firstSequence = viewSequences[0];\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n            currentViewIndex = 0;\n        }\n\n        const finalSequence = this.sequences[this.currentIndex];\n        currentViewIndex = viewSequences.findIndex(seq => seq.id === finalSequence.id);\n\n        // Update counter\n        if (taskCounter) {\n            taskCounter.textContent = `Task ${currentViewIndex + 1} of ${viewSequences.length}`;\n        }\n\n        // Update navigation buttons\n        if (prevBtn) {\n            prevBtn.disabled = currentViewIndex <= 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = currentViewIndex >= viewSequences.length - 1;\n        }\n\n        // Render full detailed view with all metadata (pulls from \"All\" tab data)\n        const displaySequence = finalSequence;\n        taskDisplay.innerHTML = `\n            <div class=\"task-card\">\n                <div class=\"task-id\">\n                    <span class=\"task-id-label\">Sequence ID</span>\n                    ${displaySequence.id}\n                </div>\n                \n                <div class=\"task-details\">\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Features</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).features : (displaySequence.featureCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Nodes</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).nodes : (displaySequence.nodeCount || 0)}</div>\n                    </div>\n                    <div class=\"detail-item\">\n                        <div class=\"detail-label\">Ways</div>\n                        <div class=\"detail-value\">${displaySequence.features ? this.calculateStats(displaySequence.features).ways : (displaySequence.wayCount || 0)}</div>\n                    </div>\n                </div>\n\n                <div class=\"status-section\">\n                    <label class=\"status-label\" for=\"statusDropdown\">Status</label>\n                    <select id=\"statusDropdown\" class=\"status-dropdown\" data-sequence-id=\"${displaySequence.id}\">\n                        <option value=\"\" ${!displaySequence.status || displaySequence.status === '' ? 'selected' : ''}>Active (Blank)</option>\n                        <option value=\"skipped\" ${displaySequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                        <option value=\"done\" ${displaySequence.status === 'done' ? 'selected' : ''}>Done</option>\n                    </select>\n                </div>\n\n                <div class=\"action-buttons\">\n                    <button class=\"action-btn btn-export\" onclick=\"taskManager.exportToJOSM('${displaySequence.id}')\">\n                        ðŸ“¥ Export to JOSM\n                    </button>\n                    <button class=\"action-btn btn-preview\" onclick=\"taskManager.previewSequence('${displaySequence.id}')\">\n                        ðŸ‘ï¸ Preview GeoJSON\n                    </button>\n                </div>\n            </div>\n        `;\n\n        // Add event listener for status dropdown\n        const statusDropdown = document.getElementById('statusDropdown');\n        if (statusDropdown) {\n            statusDropdown.addEventListener('change', (e) => {\n                this.updateStatus(displaySequence.id, e.target.value);\n            });\n        }\n    }\n\n    findNextActiveIndex() {\n        const activeSequences = this.getActiveSequences();\n        if (activeSequences.length === 0) {\n            this.currentIndex = 0;\n            return;\n        }\n\n        // Find current sequence in active list\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentActiveIndex = activeSequences.findIndex(seq => seq.id === currentSequence?.id);\n        \n        if (currentActiveIndex >= 0) {\n            // Find the index in full sequences array\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[currentActiveIndex].id);\n        } else {\n            // Current is not active, find first active\n            this.currentIndex = this.sequences.findIndex(seq => seq.id === activeSequences[0].id);\n        }\n    }\n\n\n    async updateStatus(sequenceId, newStatus) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (sequence) {\n            sequence.status = newStatus;\n            await this.saveToStorage();\n            \n            // If in 'all' view, stay in 'all' view (don't auto-switch)\n            if (this.currentView === 'all') {\n                // Stay in current view, just update\n                this.renderCurrentTask();\n            } else {\n                // For other views, check if sequence should still be visible\n                const viewSequences = this.getCurrentViewSequences();\n                const stillInView = viewSequences.find(seq => seq.id === sequenceId);\n                if (!stillInView && viewSequences.length > 0) {\n                    // Current sequence no longer in view, go to first in view\n                    const firstSequence = viewSequences[0];\n                    this.currentIndex = this.sequences.findIndex(seq => seq.id === firstSequence.id);\n                }\n                this.renderCurrentTask();\n            }\n            \n            this.updateSummary();\n        }\n    }\n\n    showPrevious() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex > 0) {\n            const prevSequence = viewSequences[currentViewIndex - 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(prevSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    showNext() {\n        const viewSequences = this.getCurrentViewSequences();\n        if (viewSequences.length === 0) return;\n\n        const currentSequence = this.sequences[this.currentIndex];\n        const currentViewIndex = viewSequences.findIndex(seq => String(seq.id) === String(currentSequence?.id));\n\n        if (currentViewIndex < viewSequences.length - 1) {\n            const nextSequence = viewSequences[currentViewIndex + 1];\n            this.currentIndex = this.sequences.findIndex(seq => String(seq.id) === String(nextSequence.id));\n            this.renderCurrentTask();\n        }\n    }\n\n    async exportToJOSM(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSM(sequence);\n            \n            // Validate XML before sending\n            if (!josmXml || josmXml.trim().length === 0) {\n                alert('Error: Generated OSM XML is empty. Please check your data.');\n                return;\n            }\n            \n            // Check if XML contains actual data (not just comments)\n            if (!josmXml.includes('<node') && !josmXml.includes('<way')) {\n                alert('Error: Generated OSM XML contains no nodes or ways. Please check your data.');\n                return;\n            }\n            \n            console.log('Generated OSM XML:', josmXml.substring(0, 500) + '...');\n            await this.sendToJOSM(josmXml, sequenceId);\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    calculateBoundingBox(sequence) {\n        let minLat = Infinity, maxLat = -Infinity;\n        let minLon = Infinity, maxLon = -Infinity;\n        \n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n            const coords = this.extractCoordinates(feature.geometry);\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                minLat = Math.min(minLat, lat);\n                maxLat = Math.max(maxLat, lat);\n                minLon = Math.min(minLon, lon);\n                maxLon = Math.max(maxLon, lon);\n            });\n        });\n        \n        // Add a small buffer (about 100 meters) to the bounding box\n        const buffer = 0.001; // ~100 meters\n        return {\n            left: minLon - buffer,\n            right: maxLon + buffer,\n            top: maxLat + buffer,\n            bottom: minLat - buffer\n        };\n    }\n\n    async loadOsmDataForPreview(sequence) {\n        try {\n            // Calculate bounding box\n            const bbox = this.calculateBoundingBox(sequence);\n            \n            // Remove existing OSM data layer if present\n            if (this.osmDataLayer) {\n                this.map.removeLayer(this.osmDataLayer);\n                this.osmDataLayer = null;\n            }\n            \n            // Create Overpass API query to get all ways and nodes in the bounding box\n            const overpassQuery = `\n                [out:xml][timeout:25];\n                (\n                  way[\"highway\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                  relation[\"type\"=\"route\"][\"route\"~\"^(bus|tram|train|subway|light_rail|trolleybus|ferry|monorail|aerialway|share_taxi|funicular)$\"](${bbox.bottom},${bbox.left},${bbox.top},${bbox.right});\n                );\n                (._;>;);\n                out body;\n            `;\n            \n            // Fetch OSM data from Overpass API\n            const overpassUrl = 'https://overpass-api.de/api/interpreter';\n            console.log('Loading OSM data for preview...');\n            \n            const response = await fetch(overpassUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(overpassQuery)}`\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Overpass API error: ${response.status}`);\n            }\n            \n            const osmXml = await response.text();\n            \n            // Parse OSM XML and convert to GeoJSON\n            const osmGeoJson = this.parseOsmXmlToGeoJson(osmXml);\n            \n            if (osmGeoJson && osmGeoJson.features && osmGeoJson.features.length > 0) {\n                // Add OSM data as a layer with distinct styling (gray, thinner)\n                this.osmDataLayer = L.geoJSON(osmGeoJson, {\n                    style: (feature) => {\n                        // Style OSM data differently from GPS trace\n                        const highway = feature.properties?.highway;\n                        let color = '#888888'; // Default gray\n                        let weight = 2;\n                        \n                        // Color code by highway type\n                        if (highway === 'motorway' || highway === 'trunk') {\n                            color = '#ff6b6b';\n                            weight = 3;\n                        } else if (highway === 'primary') {\n                            color = '#ffa500';\n                            weight = 2.5;\n                        } else if (highway === 'secondary') {\n                            color = '#ffd700';\n                            weight = 2;\n                        } else if (highway === 'tertiary') {\n                            color = '#90ee90';\n                            weight = 2;\n                        } else if (highway === 'residential' || highway === 'unclassified') {\n                            color = '#c0c0c0';\n                            weight = 1.5;\n                        }\n                        \n                        return {\n                            color: color,\n                            weight: weight,\n                            opacity: 0.6,\n                            dashArray: '5, 5' // Dashed line to distinguish from GPS trace\n                        };\n                    },\n                    onEachFeature: (feature, layer) => {\n                        // Mark this layer as OSM data layer (editable)\n                        layer._isOsmDataLayer = true;\n                        // Store original feature for reference\n                        layer.feature = feature;\n                        // OSM data is now editable, so keep it interactive\n                    }\n                }).addTo(this.map);\n                \n                console.log(`Loaded ${osmGeoJson.features.length} OSM features for preview`);\n            } else {\n                console.log('No OSM data found in the area');\n            }\n        } catch (error) {\n            console.warn('Failed to load OSM data for preview:', error);\n            // Continue without OSM data - not critical\n        }\n    }\n\n    parseOsmXmlToGeoJson(osmXml) {\n        try {\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(osmXml, 'text/xml');\n            \n            // Check for parsing errors\n            const parserError = xmlDoc.querySelector('parsererror');\n            if (parserError) {\n                throw new Error('XML parsing error');\n            }\n            \n            const nodes = new Map();\n            const ways = [];\n            const relations = [];\n            \n            // Clear previous OSM data\n            this.osmNodes.clear();\n            this.osmWays = [];\n            \n            // Parse nodes\n            xmlDoc.querySelectorAll('node').forEach(nodeEl => {\n                const id = nodeEl.getAttribute('id');\n                const lat = parseFloat(nodeEl.getAttribute('lat'));\n                const lon = parseFloat(nodeEl.getAttribute('lon'));\n                \n                const tags = {};\n                nodeEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                nodes.set(id, { id, lat, lon, tags });\n                // Store in osmNodes for snapping\n                this.osmNodes.set(id, { lat, lon });\n            });\n            \n            // Parse ways\n            xmlDoc.querySelectorAll('way').forEach(wayEl => {\n                const id = wayEl.getAttribute('id');\n                const ndRefs = [];\n                \n                wayEl.querySelectorAll('nd').forEach(nd => {\n                    ndRefs.push(nd.getAttribute('ref'));\n                });\n                \n                const tags = {};\n                wayEl.querySelectorAll('tag').forEach(tag => {\n                    tags[tag.getAttribute('k')] = tag.getAttribute('v');\n                });\n                \n                // Only include ways with highway tag (roads)\n                if (tags.highway) {\n                    ways.push({ id, ndRefs, tags });\n                    // Store way coordinates for snapping reference\n                    const wayCoords = ndRefs\n                        .map(ref => {\n                            const node = nodes.get(ref);\n                            if (node) {\n                                return { lat: node.lat, lon: node.lon };\n                            }\n                            return null;\n                        })\n                        .filter(coord => coord !== null);\n                    if (wayCoords.length >= 2) {\n                        this.osmWays.push({ id, coordinates: wayCoords, tags });\n                    }\n                }\n            });\n            \n            // Convert ways to GeoJSON LineStrings\n            const features = ways.map(way => {\n                const coordinates = way.ndRefs\n                    .map(ref => {\n                        const node = nodes.get(ref);\n                        if (node) {\n                            return [node.lon, node.lat];\n                        }\n                        return null;\n                    })\n                    .filter(coord => coord !== null);\n                \n                if (coordinates.length < 2) {\n                    return null; // Skip invalid ways\n                }\n                \n                return {\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        ...way.tags,\n                        osm_id: way.id\n                    }\n                };\n            }).filter(f => f !== null);\n            \n            console.log(`Parsed ${this.osmNodes.size} OSM nodes and ${this.osmWays.length} OSM ways for snapping`);\n            \n            return {\n                type: 'FeatureCollection',\n                features: features\n            };\n        } catch (error) {\n            console.error('Error parsing OSM XML:', error);\n            return { type: 'FeatureCollection', features: [] };\n        }\n    }\n\n    async sendToJOSM(josmXml, sequenceId) {\n        // First, check if JOSM is running and accessible\n        try {\n            const versionResponse = await fetch('http://localhost:8111/version');\n            if (!versionResponse.ok) {\n                throw new Error('JOSM Remote Control is not responding. Please ensure JOSM is running and Remote Control is enabled.');\n            }\n            const version = await versionResponse.text();\n            console.log('JOSM version:', version);\n        } catch (error) {\n            console.error('JOSM connectivity check failed:', error);\n            const proceed = confirm('Cannot connect to JOSM Remote Control.\\n\\nPlease ensure:\\n1. JOSM is running\\n2. Remote Control is enabled (Edit â†’ Preferences â†’ Remote Control)\\n3. Port 8111 is not blocked\\n\\nWould you like to try anyway, or download the file instead?');\n            if (!proceed) {\n                this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                return;\n            }\n        }\n        \n        console.log('Sending to JOSM:', {\n            xmlLength: josmXml.length\n        });\n        \n        // Get the sequence to calculate bounding box\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            console.error('Sequence not found for bounding box calculation');\n            // Continue without OSM data download\n        } else {\n            // Step 1: Download OSM data for the area\n            try {\n                const bbox = this.calculateBoundingBox(sequence);\n                console.log('Step 1: Downloading OSM data for bounding box:', bbox);\n                \n                // Use JOSM's load_and_zoom endpoint to download OSM data\n                const loadUrl = `http://localhost:8111/load_and_zoom?left=${bbox.left}&right=${bbox.right}&top=${bbox.top}&bottom=${bbox.bottom}`;\n                console.log('JOSM load_and_zoom URL:', loadUrl);\n                \n                // Use iframe to trigger JOSM to download OSM data\n                const loadIframe = document.createElement('iframe');\n                loadIframe.style.display = 'none';\n                loadIframe.style.width = '0';\n                loadIframe.style.height = '0';\n                loadIframe.src = loadUrl;\n                document.body.appendChild(loadIframe);\n                \n                // Wait a bit for OSM data to load before loading GPS trace\n                setTimeout(() => {\n                    document.body.removeChild(loadIframe);\n                    console.log('OSM data download triggered');\n                }, 1000);\n            } catch (error) {\n                console.warn('Failed to download OSM data, continuing with GPS trace only:', error);\n            }\n        }\n        \n        // Method 2: Use server-side export + JOSM import endpoint (most reliable)\n        // This avoids URL length limits and encoding issues\n        try {\n            console.log('Step 2: Uploading GPS trace OSM XML to server...');\n            \n            // POST the OSM XML to our server\n            const response = await fetch('http://localhost:8000/export', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({\n                    sequenceId: sequenceId,\n                    osmXml: josmXml\n                })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Server error: ${response.status}`);\n            }\n            \n            const result = await response.json();\n            \n            if (!result.success || !result.url) {\n                throw new Error('Server did not return file URL');\n            }\n            \n            console.log('Step 3: File available at:', result.url);\n            console.log('Step 4: Sending GPS trace to JOSM via import endpoint...');\n            \n            // Wait longer to ensure OSM data is fully loaded first, then load GPS trace\n            const waitTime = sequence ? 5000 : 500; // Wait 5 seconds if OSM data was downloaded\n            setTimeout(() => {\n                // Method 1: Try import endpoint first (preferred for URL-based import)\n                const josmImportUrl = `http://localhost:8111/import?url=${encodeURIComponent(result.url)}`;\n                console.log('JOSM import URL:', josmImportUrl);\n                \n                // Use iframe to trigger JOSM import\n                const iframe = document.createElement('iframe');\n                iframe.style.display = 'none';\n                iframe.style.width = '0';\n                iframe.style.height = '0';\n                iframe.src = josmImportUrl;\n                document.body.appendChild(iframe);\n                \n                // Also try load_data as a fallback method (more reliable for some JOSM versions)\n                setTimeout(() => {\n                    // Fetch the OSM XML content and send via load_data as backup\n                    fetch(result.url)\n                        .then(response => response.text())\n                        .then(osmContent => {\n                            // Try load_data method as fallback\n                            const base64Data = btoa(unescape(encodeURIComponent(osmContent)));\n                            const loadDataUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                            \n                            const backupIframe = document.createElement('iframe');\n                            backupIframe.style.display = 'none';\n                            backupIframe.style.width = '0';\n                            backupIframe.style.height = '0';\n                            backupIframe.src = loadDataUrl;\n                            document.body.appendChild(backupIframe);\n                            \n                            setTimeout(() => {\n                                document.body.removeChild(backupIframe);\n                            }, 2000);\n                        })\n                        .catch(err => {\n                            console.warn('Backup load_data method failed:', err);\n                        });\n                }, 2000);\n                \n                // Check if import worked after a delay\n                setTimeout(() => {\n                    document.body.removeChild(iframe);\n                    \n                    // Verify the file is accessible and provide user feedback\n                    fetch(result.url)\n                        .then(response => {\n                            if (response.ok) {\n                                console.log('GPS trace file is accessible at:', result.url);\n                                alert('âœ… Data sent to JOSM!\\n\\n' +\n                                      'OSM map data has been downloaded for the area.\\n' +\n                                      'Your GPS trace has been loaded on top as a new layer.\\n\\n' +\n                                      'Please check your JOSM window - you can now merge/edit based on OSM data.\\n\\n' +\n                                      'If the GPS trace is not visible:\\n' +\n                                      '1. Check the layer panel in JOSM (should show multiple layers)\\n' +\n                                      '2. Make sure the GPS trace layer is visible/active\\n' +\n                                      '3. Try zooming to the area');\n                            } else {\n                                console.error('GPS trace file not accessible:', response.status);\n                                alert('âš ï¸ GPS trace file uploaded, but there may be an issue loading it in JOSM.\\n\\n' +\n                                      'File URL: ' + result.url + '\\n\\n' +\n                                      'Please check:\\n' +\n                                      '1. JOSM Remote Control is enabled\\n' +\n                                      '2. Check JOSM layers panel for the imported data\\n' +\n                                      '3. Try manually importing: File â†’ Open â†’ ' + result.url);\n                            }\n                        })\n                        .catch(err => {\n                            console.error('Error verifying GPS trace file:', err);\n                            alert('âš ï¸ GPS trace uploaded, but verification failed.\\n\\n' +\n                                  'File URL: ' + result.url + '\\n\\n' +\n                                  'Please check JOSM - the data may still have loaded.\\n' +\n                                  'If not visible, try: File â†’ Open â†’ ' + result.url);\n                        });\n                }, 4000);\n            }, waitTime);\n            \n            return;\n            \n        } catch (error) {\n            console.error('Server-based export failed:', error);\n            console.log('Falling back to direct download...');\n            \n            // Fallback: direct file download\n            this.downloadAndOpenInJOSM(josmXml, sequenceId);\n        }\n    }\n    \n    downloadAndOpenInJOSM(josmXml, sequenceId) {\n        // Download the file\n        this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        \n        // Provide helpful instructions\n        alert('ðŸ“¥ File downloaded!\\n\\n' +\n              'To open in JOSM:\\n' +\n              '1. Go to JOSM\\n' +\n              '2. File â†’ Open (or press Ctrl+O)\\n' +\n              '3. Navigate to your Downloads folder\\n' +\n              '4. Select: sequence_' + sequenceId + '.osm\\n' +\n              '5. Click Open\\n\\n' +\n              'Or simply drag and drop the file into JOSM!');\n    }\n\n    generateJOSM(sequence) {\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n            xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Only add highway tag (user requested only highway tag)\n            const highwayValue = feature.properties?.highway || 'unclassified';\n            xml += `    <tag k=\"highway\" v=\"${this.escapeXml(String(highwayValue))}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n    async previewSequence(sequenceId) {\n        const sequence = this.sequences.find(s => String(s.id) === String(sequenceId));\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        this.currentPreviewSequence = sequence;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(sequence.features)); // Deep copy for revert\n        this.editableLayers = [];\n        \n        document.getElementById('previewSequenceId').textContent = sequenceId;\n        \n        // Set initial highway value in selector\n        const highwaySelect = document.getElementById('highwaySelect');\n        if (highwaySelect) {\n            // Get highway value from first feature, or default to 'unclassified'\n            const highwayValue = sequence.features[0]?.properties?.highway || 'unclassified';\n            highwaySelect.value = highwayValue;\n        }\n        \n        // Reset edit mode UI\n        document.getElementById('toggleEditModeBtn').style.display = 'inline-block';\n        document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n        document.getElementById('saveEditsBtn').style.display = 'none';\n        document.getElementById('revertEditsBtn').style.display = 'none';\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                // Default to Singapore coordinates (as per user preference)\n                this.map = L.map('previewMap', {\n                    zoomControl: true,\n                    maxZoom: 22,  // Allow higher zoom levels for detailed editing\n                    preferCanvas: true,  // Use canvas renderer for better performance\n                    renderer: L.canvas({ padding: 0.5 })  // Optimize rendering\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer with overzooming support\n                // maxNativeZoom: 19 means tiles are available up to zoom 19\n                // maxZoom: 22 allows the map to zoom further by scaling tiles\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxNativeZoom: 19,  // Native tile zoom level\n                    maxZoom: 22,  // Allow overzooming (scaling tiles beyond native zoom)\n                    tileSize: 256,\n                    zoomOffset: 0\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer and OSM data layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON || layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) {\n                    if (!(layer instanceof L.TileLayer) && !layer._isOsmDataLayer) {\n                        this.map.removeLayer(layer);\n                    }\n                }\n            });\n            this.editableLayers = [];\n            \n            // Load OSM data for the area (async, will add to editableLayers when loaded)\n            this.loadOsmDataForPreview(sequence).then(() => {\n                // After OSM data loads, add it to editable layers\n                if (this.osmDataLayer) {\n                    this.osmDataLayer.eachLayer((layer) => {\n                        if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                            this.editableLayers.push(layer);\n                            layer.feature = layer.feature || {};\n                            layer._isOsmData = true; // Mark as OSM data\n                        }\n                    });\n                    console.log('OSM data layers added to editable layers. Total:', this.editableLayers.length);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map with blue lines (as per user preference)\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#0066ff', // Blue color as per user preference\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    // No popup - user doesn't want property popups\n                }\n            }).addTo(this.map);\n\n            // Store layers for editing (GPS trace)\n            geoJsonLayer.eachLayer((layer) => {\n                // Store the actual layer (Polyline, Polygon, or Marker)\n                this.editableLayers.push(layer);\n                // Also store reference to the feature for later use\n                layer.feature = layer.feature || {};\n                layer._isGpsTrace = true; // Mark as GPS trace\n            });\n            \n            // Store OSM data layers for editing (if OSM data is loaded)\n            if (this.osmDataLayer) {\n                this.osmDataLayer.eachLayer((layer) => {\n                    if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                        this.editableLayers.push(layer);\n                        layer.feature = layer.feature || {};\n                        layer._isOsmData = true; // Mark as OSM data\n                    }\n                });\n            }\n            \n            // Debug: log what we found\n            console.log('Editable layers found:', this.editableLayers.length);\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, layer instanceof L.Polyline, layer instanceof L.Polygon, layer instanceof L.Marker, 'GPS:', layer._isGpsTrace, 'OSM:', layer._isOsmData);\n            });\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    toggleEditMode() {\n        this.previewEditMode = !this.previewEditMode;\n        \n        if (this.previewEditMode) {\n            // Disable map dragging when edit mode is enabled to prevent conflicts with node/way dragging\n            // Users can still pan by clicking and dragging on empty map areas (we'll handle this separately if needed)\n            this.map.dragging.disable();\n            \n            // Ensure OSM data layers are included in editable layers (they are now editable)\n            if (this.osmDataLayer && this.osmDataLayer.eachLayer) {\n                this.osmDataLayer.eachLayer((layer) => {\n                    if ((layer instanceof L.Polyline || layer instanceof L.Polygon) && !this.editableLayers.includes(layer)) {\n                        this.editableLayers.push(layer);\n                        layer.feature = layer.feature || {};\n                        layer._isOsmData = true; // Mark as OSM data (but editable)\n                    }\n                });\n            }\n            \n            // Check if we have layers to edit\n            if (!this.editableLayers || this.editableLayers.length === 0) {\n                alert('No geometry found to edit. Make sure the sequence has features.');\n                this.previewEditMode = false;\n                this.map.dragging.enable(); // Re-enable if we're not entering edit mode\n                return;\n            }\n            \n            console.log('Enabling edit mode for', this.editableLayers.length, 'layers (including OSM data)');\n            \n            // Initialize undo/redo history\n            this.initializeHistory();\n            \n            // Enable editing - add draggable vertex markers\n            let layersProcessed = 0;\n            this.editableLayers.forEach((layer, idx) => {\n                console.log(`Layer ${idx}:`, layer.constructor.name, 'has getLatLngs:', typeof layer.getLatLngs === 'function');\n                \n                // Check if it's a polyline or polygon (more flexible check)\n                const isPolyline = layer instanceof L.Polyline || (layer.getLatLngs && !(layer instanceof L.Marker) && !(layer instanceof L.Circle));\n                const isPolygon = layer instanceof L.Polygon;\n                \n                if (isPolyline || isPolygon) {\n                    console.log(`  - Processing as ${isPolygon ? 'Polygon' : 'Polyline'}`);\n                    layersProcessed++;\n                    // Make the layer more visible when editing and make it draggable\n                    layer.setStyle({ weight: 6, opacity: 0.9, cursor: 'move' });\n                    \n                    // Store reference to layer for dragging\n                    layer._isDragging = false;\n                    layer._dragStart = null;\n                    layer._originalLatLngs = null;\n                    \n                    // Enable dragging the entire way by clicking on the line\n                    // Use a flag to track if mouse is down on the path\n                    layer._mouseDownOnPath = false;\n                    layer._wayDragStartLatLng = null;\n                    \n                    layer.on('mousedown', (e) => {\n                        // Check if clicking directly on the path element (not on markers)\n                        const target = e.originalEvent.target;\n                        const isOnMarker = target.closest('.vertex-marker') || target.closest('.delete-node-btn') || target.closest('.leaflet-marker-icon');\n                        \n                        if (!isOnMarker) {\n                            layer._mouseDownOnPath = true;\n                            layer._isDragging = true;\n                            layer._wayDragStartLatLng = e.latlng; // Store initial click position\n                            layer._originalLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                            // Map dragging is already disabled in edit mode, but ensure it stays disabled\n                            this.map.dragging.disable();\n                            L.DomEvent.stopPropagation(e);\n                            L.DomEvent.preventDefault(e);\n                        }\n                    });\n                    \n                    // Handle mouse move for dragging entire way\n                    // Optimized with requestAnimationFrame for smooth performance\n                    let wayDragRafId = null;\n                    const dragHandler = (e) => {\n                        if (layer._isDragging && layer._wayDragStartLatLng && layer._mouseDownOnPath && layer._originalLatLngs) {\n                            // Cancel any pending updates\n                            if (wayDragRafId) {\n                                cancelAnimationFrame(wayDragRafId);\n                            }\n                            \n                            // Use requestAnimationFrame to batch updates\n                            wayDragRafId = requestAnimationFrame(() => {\n                                // Calculate delta from the original click position, not from last position\n                                const deltaLat = e.latlng.lat - layer._wayDragStartLatLng.lat;\n                                const deltaLng = e.latlng.lng - layer._wayDragStartLatLng.lng;\n                                \n                                // Apply delta to original positions\n                                const newLatLngs = layer._originalLatLngs.map(ll => {\n                                    if (ll instanceof L.LatLng) {\n                                        return L.latLng(ll.lat + deltaLat, ll.lng + deltaLng);\n                                    } else if (Array.isArray(ll)) {\n                                        return L.latLng(ll[0] + deltaLat, ll[1] + deltaLng);\n                                    }\n                                    return L.latLng((ll.lat || ll[0]) + deltaLat, (ll.lng || ll[1]) + deltaLng);\n                                });\n                                \n                                // Update layer without triggering events that might cause feedback\n                                layer.setLatLngs(layer instanceof L.Polygon ? [newLatLngs] : newLatLngs);\n                                \n                                // Update vertex markers in real-time during drag for visual feedback\n                                // Update marker positions directly (synchronously) so they move with the way\n                                if (layer._vertexMarkers && layer._vertexMarkers.length === newLatLngs.length) {\n                                    // Update existing markers directly for immediate visual feedback\n                                    newLatLngs.forEach((latlng, index) => {\n                                        if (layer._vertexMarkers[index]) {\n                                            let lat, lng;\n                                            if (latlng instanceof L.LatLng) {\n                                                lat = latlng.lat;\n                                                lng = latlng.lng;\n                                            } else if (Array.isArray(latlng)) {\n                                                lat = latlng[0];\n                                                lng = latlng[1];\n                                            } else {\n                                                lat = latlng.lat || latlng[0];\n                                                lng = latlng.lng || latlng[1];\n                                            }\n                                            layer._vertexMarkers[index].setLatLng([lat, lng]);\n                                        }\n                                    });\n                                } else {\n                                    // If marker count doesn't match, recreate markers (shouldn't happen during drag)\n                                    if (!layer._updatingMarkers) {\n                                        layer._updatingMarkers = true;\n                                        this.updateVertexMarkers(layer, newLatLngs);\n                                        layer._updatingMarkers = false;\n                                    }\n                                }\n                                \n                                wayDragRafId = null;\n                            });\n                        }\n                    };\n                    \n                    // Handle mouse up for dragging entire way\n                    const dragEndHandler = () => {\n                        if (layer._isDragging) {\n                            layer._isDragging = false;\n                            layer._mouseDownOnPath = false;\n                            layer._wayDragStartLatLng = null;\n                            \n                            // Final update of markers\n                            if (layer._originalLatLngs) {\n                                const currentLatLngs = this.flattenLatLngs(layer.getLatLngs());\n                                this.updateVertexMarkers(layer, currentLatLngs);\n                            }\n                            \n                            layer._originalLatLngs = null;\n                            \n                            // Save state after way drag completes\n                            this.saveStateToHistory();\n                            \n                            // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n                        }\n                    };\n                    \n                    this.map.on('mousemove', dragHandler);\n                    this.map.on('mouseup', dragEndHandler);\n                    this.map.on('mouseleave', dragEndHandler); // Also handle mouse leaving map\n                    \n                    // Store handlers for cleanup\n                    layer._dragHandler = dragHandler;\n                    layer._dragEndHandler = dragEndHandler;\n                    \n                    // Add node by clicking on the line\n                    layer.on('click', (e) => {\n                        // Don't add node if we just finished dragging or clicked on marker\n                        if (layer._isDragging || layer._mouseDownOnPath || \n                            e.originalEvent.target.closest('.vertex-marker') || \n                            e.originalEvent.target.closest('.delete-node-btn') ||\n                            e.originalEvent.target.closest('.leaflet-marker-icon')) {\n                            // Reset flag after a short delay\n                            setTimeout(() => {\n                                layer._mouseDownOnPath = false;\n                            }, 100);\n                            return;\n                        }\n                        \n                        const clickLatLng = e.latlng;\n                        const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                        \n                        // Find the closest segment\n                        let minDistance = Infinity;\n                        let insertIndex = -1;\n                        \n                        for (let i = 0; i < latlngs.length - 1; i++) {\n                            const segStart = latlngs[i];\n                            const segEnd = latlngs[i + 1];\n                            const startLL = segStart instanceof L.LatLng ? segStart : L.latLng(segStart[0] || segStart.lat, segStart[1] || segStart.lng);\n                            const endLL = segEnd instanceof L.LatLng ? segEnd : L.latLng(segEnd[0] || segEnd.lat, segEnd[1] || segEnd.lng);\n                            const distance = this.distanceToSegment(clickLatLng, startLL, endLL);\n                            \n                            if (distance < minDistance) {\n                                minDistance = distance;\n                                insertIndex = i + 1;\n                            }\n                        }\n                        \n                        // Insert new node\n                        if (insertIndex > 0) {\n                            // Save state before adding node\n                            this.saveStateToHistory();\n                            \n                            latlngs.splice(insertIndex, 0, clickLatLng);\n                            layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                            this.updateVertexMarkers(layer, latlngs);\n                        }\n                    });\n                    \n                    // Get all coordinates\n                    let latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (Array.isArray(flatLatlngs) && flatLatlngs.length > 0) {\n                        this.updateVertexMarkers(layer, flatLatlngs);\n                    }\n                } else if (layer instanceof L.Marker) {\n                    console.log(`  - Processing as Marker`);\n                    layer.dragging.enable();\n                    layersProcessed++;\n                } else {\n                    console.log(`  - Skipping layer (not Polyline/Polygon/Marker)`);\n                }\n            });\n            \n            console.log(`Total layers processed: ${layersProcessed}`);\n            \n            if (layersProcessed === 0) {\n                alert('No editable geometry found. The sequence may only contain unsupported geometry types. Check the browser console for details.');\n                this.previewEditMode = false;\n                document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n                document.getElementById('simplifyBtn').style.display = 'none';\n                document.getElementById('toleranceInput').style.display = 'none';\n                document.getElementById('saveEditsBtn').style.display = 'none';\n                document.getElementById('revertEditsBtn').style.display = 'none';\n                return;\n            }\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'ðŸ‘ï¸ Disable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'inline-block';\n            document.getElementById('redoBtn').style.display = 'inline-block';\n            document.getElementById('simplifyBtn').style.display = 'inline-block';\n            document.getElementById('toleranceInput').style.display = 'inline-block';\n            document.getElementById('saveEditsBtn').style.display = 'inline-block';\n            document.getElementById('revertEditsBtn').style.display = 'inline-block';\n            \n            // Initialize undo/redo button states\n            this.updateUndoRedoButtons();\n            \n            // Add keyboard shortcuts for undo/redo\n            this._keyboardHandler = (e) => {\n                // Ctrl+Z or Cmd+Z for undo\n                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {\n                    e.preventDefault();\n                    this.undo();\n                }\n                // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo\n                else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {\n                    e.preventDefault();\n                    this.redo();\n                }\n            };\n            document.addEventListener('keydown', this._keyboardHandler);\n        } else {\n            // Disable editing - remove vertex markers and event handlers\n            // Re-enable map dragging\n            this.map.dragging.enable();\n            \n            this.editableLayers.forEach(layer => {\n                if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                    // Remove event handlers\n                    layer.off('mousedown');\n                    layer.off('click');\n                    if (layer._dragHandler) {\n                        this.map.off('mousemove', layer._dragHandler);\n                    }\n                    if (layer._dragEndHandler) {\n                        this.map.off('mouseup', layer._dragEndHandler);\n                        this.map.off('mouseleave', layer._dragEndHandler);\n                    }\n                    \n                    // Remove vertex markers\n                    if (layer._vertexMarkers) {\n                        layer._vertexMarkers.forEach(marker => {\n                            this.map.removeLayer(marker);\n                        });\n                        layer._vertexMarkers = [];\n                    }\n                    // Restore original style\n                    layer.setStyle({ weight: 4, opacity: 0.8, cursor: '' });\n                } else if (layer instanceof L.Marker) {\n                    layer.dragging.disable();\n                }\n            });\n            \n            document.getElementById('toggleEditModeBtn').textContent = 'âœï¸ Enable Edit Mode';\n            document.getElementById('undoBtn').style.display = 'none';\n            document.getElementById('redoBtn').style.display = 'none';\n            document.getElementById('simplifyBtn').style.display = 'none';\n            document.getElementById('toleranceInput').style.display = 'none';\n            document.getElementById('saveEditsBtn').style.display = 'none';\n            document.getElementById('revertEditsBtn').style.display = 'none';\n            \n            // Remove keyboard shortcuts\n            if (this._keyboardHandler) {\n                document.removeEventListener('keydown', this._keyboardHandler);\n                this._keyboardHandler = null;\n            }\n        }\n    }\n\n    // Save current geometry state to history for undo/redo\n    // Debounced to prevent excessive history saves during rapid operations\n    saveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return; // Nothing to save\n        }\n        \n        // Debounce history saves for performance (only save after operations complete)\n        if (this._historySaveTimeout) {\n            clearTimeout(this._historySaveTimeout);\n        }\n        \n        this._historySaveTimeout = setTimeout(() => {\n            this._doSaveStateToHistory();\n            this._historySaveTimeout = null;\n        }, 100); // Wait 100ms after last operation before saving\n    }\n    \n    // Internal method to actually save state\n    _doSaveStateToHistory() {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return;\n        }\n        \n        // Capture current state of all editable layers\n        const state = this.editableLayers.map(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                // Convert to serializable format [lat, lng]\n                return {\n                    type: layer instanceof L.Polygon ? 'Polygon' : 'Polyline',\n                    latlngs: latlngs.map(ll => {\n                        if (ll instanceof L.LatLng) {\n                            return [ll.lat, ll.lng];\n                        } else if (Array.isArray(ll)) {\n                            return [ll[0] || ll.lat, ll[1] || ll.lng];\n                        }\n                        return [ll.lat || ll[0], ll.lng || ll[1]];\n                    })\n                };\n            } else if (layer instanceof L.Marker) {\n                const latlng = layer.getLatLng();\n                return {\n                    type: 'Marker',\n                    latlng: [latlng.lat, latlng.lng]\n                };\n            }\n            return null;\n        }).filter(s => s !== null);\n        \n        // Remove any states after current index (when user did undo, then made new edit)\n        if (this.currentHistoryIndex < this.editHistory.length - 1) {\n            this.editHistory = this.editHistory.slice(0, this.currentHistoryIndex + 1);\n        }\n        \n        // Add new state\n        this.editHistory.push(state);\n        this.currentHistoryIndex = this.editHistory.length - 1;\n        \n        // Limit history size\n        if (this.editHistory.length > this.maxHistorySize) {\n            this.editHistory.shift();\n            this.currentHistoryIndex--;\n        }\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('State saved to history. Index:', this.currentHistoryIndex, 'Total states:', this.editHistory.length);\n    }\n\n    // Restore geometry state from history\n    restoreStateFromHistory(state) {\n        if (!state || !this.editableLayers) return;\n        \n        state.forEach((layerState, idx) => {\n            if (idx >= this.editableLayers.length) return;\n            \n            const layer = this.editableLayers[idx];\n            \n            if (layerState.type === 'Polyline' || layerState.type === 'Polygon') {\n                // Convert back to LatLng objects\n                const latlngs = layerState.latlngs.map(ll => L.latLng(ll[0], ll[1]));\n                \n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([latlngs]);\n                } else {\n                    layer.setLatLngs(latlngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, latlngs);\n            } else if (layerState.type === 'Marker' && layer instanceof L.Marker) {\n                const latlng = L.latLng(layerState.latlng[0], layerState.latlng[1]);\n                layer.setLatLng(latlng);\n            }\n        });\n    }\n\n    // Undo last edit\n    undo() {\n        if (this.currentHistoryIndex <= 0) {\n            console.log('Nothing to undo');\n            return;\n        }\n        \n        // Move back in history\n        this.currentHistoryIndex--;\n        const previousState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore previous state\n        this.restoreStateFromHistory(previousState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Undo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Redo last undone edit\n    redo() {\n        if (this.currentHistoryIndex >= this.editHistory.length - 1) {\n            console.log('Nothing to redo');\n            return;\n        }\n        \n        // Move forward in history\n        this.currentHistoryIndex++;\n        const nextState = this.editHistory[this.currentHistoryIndex];\n        \n        // Restore next state\n        this.restoreStateFromHistory(nextState);\n        \n        // Update button states\n        this.updateUndoRedoButtons();\n        \n        console.log('Redo performed. Current index:', this.currentHistoryIndex);\n    }\n\n    // Update undo/redo button states\n    updateUndoRedoButtons() {\n        const undoBtn = document.getElementById('undoBtn');\n        const redoBtn = document.getElementById('redoBtn');\n        \n        if (undoBtn) {\n            undoBtn.disabled = this.currentHistoryIndex <= 0;\n            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';\n            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n        \n        if (redoBtn) {\n            redoBtn.disabled = this.currentHistoryIndex >= this.editHistory.length - 1;\n            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';\n            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';\n        }\n    }\n\n    // Initialize history when entering edit mode\n    initializeHistory() {\n        // Clear history and save initial state\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        this.saveStateToHistory(); // Save initial state\n    }\n\n    // Helper: Flatten latlngs array\n    flattenLatLngs(arr) {\n        if (!arr) return [];\n        if (!Array.isArray(arr)) {\n            if (arr instanceof L.LatLng) return [arr];\n            return [];\n        }\n        \n        const result = [];\n        arr.forEach(item => {\n            if (item instanceof L.LatLng) {\n                result.push(item);\n            } else if (Array.isArray(item)) {\n                if (item.length > 0) {\n                    if (item[0] instanceof L.LatLng) {\n                        result.push(...item);\n                    } else if (Array.isArray(item[0])) {\n                        result.push(...this.flattenLatLngs(item));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n\n    // Helper: Update vertex markers for a layer\n    updateVertexMarkers(layer, latlngs) {\n        // Performance optimization: Use requestAnimationFrame for smooth updates\n        if (layer._updatingMarkers) {\n            return; // Already updating, skip to prevent duplicate updates\n        }\n        \n        layer._updatingMarkers = true;\n        \n        // Use requestAnimationFrame for smooth rendering\n        requestAnimationFrame(() => {\n            // Clear existing markers efficiently\n            if (layer._vertexMarkers) {\n                layer._vertexMarkers.forEach(marker => {\n                    // Remove all event listeners before removing from map\n                    marker.off();\n                    this.map.removeLayer(marker);\n                });\n            }\n            layer._vertexMarkers = [];\n            \n            // Add markers for each vertex\n            latlngs.forEach((latlng, index) => {\n            let lat, lng;\n            if (latlng instanceof L.LatLng) {\n                lat = latlng.lat;\n                lng = latlng.lng;\n            } else if (Array.isArray(latlng)) {\n                lat = latlng[0];\n                lng = latlng[1];\n            } else {\n                lat = latlng.lat || latlng[0];\n                lng = latlng.lng || latlng[1];\n            }\n            \n            // Vertex marker\n            const marker = L.marker([lat, lng], {\n                draggable: true,\n                icon: L.divIcon({\n                    className: 'vertex-marker',\n                    html: '<div class=\"vertex-handle\"></div>',\n                    iconSize: [12, 12]\n                }),\n                zIndexOffset: 1100, // Higher than delete button (1000) to ensure marker is on top\n                interactive: true\n            }).addTo(this.map);\n            \n            // No delete button needed - clicking the node itself will delete it\n            // Ensure marker dragging is enabled\n            marker.dragging.enable();\n            marker.setZIndexOffset(1100);\n            \n            // Track mouse state to distinguish between click (delete) and drag (move)\n            marker._mouseDownPos = null;\n            marker._hasMoved = false;\n            marker._clickTimeout = null;\n            marker._isDragging = false;\n            \n            // Handle mousedown - track initial position\n            marker.on('mousedown', (e) => {\n                // Disable map dragging when clicking on marker\n                this.map.dragging.disable();\n                // Store initial mouse position\n                marker._mouseDownPos = {\n                    x: e.originalEvent.clientX,\n                    y: e.originalEvent.clientY,\n                    latlng: e.latlng\n                };\n                marker._hasMoved = false;\n                marker._isDragging = false;\n                \n                // Set a timeout to detect click (if no drag happens)\n                marker._clickTimeout = setTimeout(() => {\n                    // If mouse hasn't moved significantly and drag hasn't started, treat as click\n                    if (!marker._hasMoved && !marker._isDragging) {\n                        // This will be handled by mouseup if it's still a click\n                    }\n                }, 50);\n            });\n            \n            // Handle mousemove on marker to detect if it's a drag\n            marker.on('mousemove', (e) => {\n                if (marker._mouseDownPos) {\n                    const dx = Math.abs(e.originalEvent.clientX - marker._mouseDownPos.x);\n                    const dy = Math.abs(e.originalEvent.clientY - marker._mouseDownPos.y);\n                    // If mouse moved more than 5 pixels, it's a drag\n                    if (dx > 5 || dy > 5) {\n                        marker._hasMoved = true;\n                        // Clear click timeout since this is a drag\n                        if (marker._clickTimeout) {\n                            clearTimeout(marker._clickTimeout);\n                            marker._clickTimeout = null;\n                        }\n                    }\n                }\n            });\n            \n            // Handle click (mouseup without significant movement) = DELETE\n            marker.on('click', (e) => {\n                // Only delete if it wasn't a drag\n                if (!marker._hasMoved && !marker._isDragging) {\n                    e.originalEvent.stopPropagation();\n                    e.originalEvent.preventDefault();\n                    \n                    if (latlngs.length > 2) { // Keep at least 2 points\n                        // Save state before deleting node\n                        this.saveStateToHistory();\n                        \n                        latlngs.splice(index, 1);\n                        layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                        this.updateVertexMarkers(layer, latlngs);\n                    } else {\n                        alert('Cannot delete node. A line must have at least 2 points.');\n                    }\n                }\n                \n                // Reset state\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n            });\n            \n            // Handle dragstart - this is a DRAG, not a click\n            marker.on('dragstart', (e) => {\n                // Mark as dragging\n                marker._isDragging = true;\n                marker._hasMoved = true;\n                \n                // Clear click timeout since this is a drag\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                \n                // Ensure map dragging is disabled\n                this.map.dragging.disable();\n                // Stop propagation to prevent map events\n                L.DomEvent.stopPropagation(e);\n            });\n            \n            // Optimize drag handler with requestAnimationFrame for smooth performance\n            let dragRafId = null;\n            marker.on('drag', (e) => {\n                // Keep map dragging disabled during drag\n                this.map.dragging.disable();\n                // Stop propagation to prevent map from moving\n                L.DomEvent.stopPropagation(e);\n                \n                // Use requestAnimationFrame to batch updates for smooth performance\n                if (dragRafId) {\n                    cancelAnimationFrame(dragRafId);\n                }\n                \n                dragRafId = requestAnimationFrame(() => {\n                    let newLatlng = e.target.getLatLng();\n                    \n                    // Node merging: Check if this node is close to any other node from any editable layer\n                    const mergeThreshold = 0.00005; // ~5 meters\n                    const nearestNode = this.findNearestNodeFromAllLayers(newLatlng, layer, index, mergeThreshold);\n                    \n                    if (nearestNode) {\n                        // Merge: Move this node to the nearest node's position\n                        newLatlng = L.latLng(nearestNode.lat, nearestNode.lon);\n                        \n                        // Visual feedback: change marker color when merging\n                        if (!marker._isMerged) {\n                            marker._isMerged = true;\n                            const icon = marker.getIcon();\n                            if (icon && icon.options) {\n                                icon.options.html = '<div class=\"vertex-handle\" style=\"background: #00ff00; border-color: #ffffff;\"></div>';\n                                marker.setIcon(icon);\n                            }\n                        }\n                    } else {\n                        // Not merging - restore normal color\n                        if (marker._isMerged) {\n                            marker._isMerged = false;\n                            const icon = marker.getIcon();\n                            if (icon && icon.options) {\n                                icon.options.html = '<div class=\"vertex-handle\"></div>';\n                                marker.setIcon(icon);\n                            }\n                        }\n                    }\n                    \n                    if (latlngs[index] instanceof L.LatLng) {\n                        latlngs[index].lat = newLatlng.lat;\n                        latlngs[index].lng = newLatlng.lng;\n                    } else {\n                        latlngs[index] = newLatlng;\n                    }\n                    layer.setLatLngs(layer instanceof L.Polygon ? [latlngs] : latlngs);\n                    dragRafId = null;\n                });\n            });\n            \n            marker.on('dragend', (e) => {\n                // Mark that dragging has ended\n                marker._isDragging = false;\n                marker._mouseDownPos = null;\n                marker._hasMoved = false;\n                \n                // Save state after node drag completes\n                this.saveStateToHistory();\n                \n                // Stop propagation\n                L.DomEvent.stopPropagation(e);\n                // Map dragging stays disabled in edit mode (we'll re-enable when exiting edit mode)\n            });\n            \n            // Handle mouseup to clean up state\n            marker.on('mouseup', (e) => {\n                // Reset state\n                if (marker._clickTimeout) {\n                    clearTimeout(marker._clickTimeout);\n                    marker._clickTimeout = null;\n                }\n                marker._mouseDownPos = null;\n            });\n            \n            layer._vertexMarkers.push(marker);\n            });\n            \n            // Mark update as complete\n            layer._updatingMarkers = false;\n        });\n    }\n\n    // Helper: Find nearest node from all editable layers (for merging)\n    findNearestNodeFromAllLayers(latlng, currentLayer, currentIndex, threshold = 0.00005) {\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            return null;\n        }\n        \n        let nearestNode = null;\n        let minDistance = Infinity;\n        \n        const lat = latlng instanceof L.LatLng ? latlng.lat : latlng[0] || latlng.lat;\n        const lon = latlng instanceof L.LatLng ? latlng.lng : latlng[1] || latlng.lng;\n        \n        // Check all editable layers\n        this.editableLayers.forEach((layer) => {\n            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {\n                const layerLatlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                layerLatlngs.forEach((nodeLatlng, nodeIndex) => {\n                    // Skip the current node being dragged\n                    if (layer === currentLayer && nodeIndex === currentIndex) {\n                        return;\n                    }\n                    \n                    let nodeLat, nodeLon;\n                    if (nodeLatlng instanceof L.LatLng) {\n                        nodeLat = nodeLatlng.lat;\n                        nodeLon = nodeLatlng.lng;\n                    } else if (Array.isArray(nodeLatlng)) {\n                        nodeLat = nodeLatlng[0] || nodeLatlng.lat;\n                        nodeLon = nodeLatlng[1] || nodeLatlng.lng;\n                    } else {\n                        nodeLat = nodeLatlng.lat || nodeLatlng[0];\n                        nodeLon = nodeLatlng.lng || nodeLatlng[1];\n                    }\n                    \n                    const dx = nodeLon - lon;\n                    const dy = nodeLat - lat;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    \n                    if (distance < minDistance && distance <= threshold) {\n                        minDistance = distance;\n                        nearestNode = { \n                            lat: nodeLat, \n                            lon: nodeLon, \n                            layer: layer,\n                            index: nodeIndex,\n                            distance: distance \n                        };\n                    }\n                });\n            }\n        });\n        \n        return nearestNode;\n    }\n    \n    // Helper: Find nearest OSM node for snapping (kept for potential future use)\n    findNearestOsmNode(latlng, threshold = null) {\n        if (!this.osmNodes || this.osmNodes.size === 0) {\n            return null;\n        }\n        \n        const thresholdDist = threshold || this.snapThreshold;\n        let nearestNode = null;\n        let minDistance = Infinity;\n        \n        const lat = latlng instanceof L.LatLng ? latlng.lat : latlng[0] || latlng.lat;\n        const lon = latlng instanceof L.LatLng ? latlng.lng : latlng[1] || latlng.lng;\n        \n        this.osmNodes.forEach((node, nodeId) => {\n            const dx = node.lon - lon;\n            const dy = node.lat - lat;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            \n            if (distance < minDistance && distance <= thresholdDist) {\n                minDistance = distance;\n                nearestNode = { lat: node.lat, lon: node.lon, id: nodeId, distance: distance };\n            }\n        });\n        \n        return nearestNode;\n    }\n    \n    // Helper: Calculate distance between two lat/lng points\n    calculateDistance(latlng1, latlng2) {\n        const lat1 = latlng1 instanceof L.LatLng ? latlng1.lat : latlng1[0] || latlng1.lat;\n        const lon1 = latlng1 instanceof L.LatLng ? latlng1.lng : latlng1[1] || latlng1.lng;\n        const lat2 = latlng2 instanceof L.LatLng ? latlng2.lat : latlng2[0] || latlng2.lat;\n        const lon2 = latlng2 instanceof L.LatLng ? latlng2.lng : latlng2[1] || latlng2.lng;\n        \n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    \n    // Helper: Calculate distance from point to line segment\n    distanceToSegment(point, segStart, segEnd) {\n        const A = point.lat - segStart.lat;\n        const B = point.lng - segStart.lng;\n        const C = segEnd.lat - segStart.lat;\n        const D = segEnd.lng - segStart.lng;\n        \n        const dot = A * C + B * D;\n        const lenSq = C * C + D * D;\n        let param = -1;\n        \n        if (lenSq !== 0) param = dot / lenSq;\n        \n        let xx, yy;\n        \n        if (param < 0) {\n            xx = segStart.lat;\n            yy = segStart.lng;\n        } else if (param > 1) {\n            xx = segEnd.lat;\n            yy = segEnd.lng;\n        } else {\n            xx = segStart.lat + param * C;\n            yy = segStart.lng + param * D;\n        }\n        \n        const dx = point.lat - xx;\n        const dy = point.lng - yy;\n        return Math.sqrt(dx * dx + dy * dy) * 111000; // Convert to approximate meters\n    }\n\n    // Douglas-Peucker line simplification algorithm\n    douglasPeucker(points, tolerance) {\n        if (points.length <= 2) return points;\n        \n        // Find the point with maximum distance from line between first and last point\n        let maxDistance = 0;\n        let maxIndex = 0;\n        const first = points[0];\n        const last = points[points.length - 1];\n        \n        for (let i = 1; i < points.length - 1; i++) {\n            const distance = this.perpendicularDistance(points[i], first, last);\n            if (distance > maxDistance) {\n                maxDistance = distance;\n                maxIndex = i;\n            }\n        }\n        \n        // If max distance is greater than tolerance, recursively simplify\n        if (maxDistance > tolerance) {\n            // Recursive call on both sides\n            const left = this.douglasPeucker(points.slice(0, maxIndex + 1), tolerance);\n            const right = this.douglasPeucker(points.slice(maxIndex), tolerance);\n            \n            // Combine results (remove duplicate point at junction)\n            return left.slice(0, -1).concat(right);\n        } else {\n            // Return only endpoints\n            return [first, last];\n        }\n    }\n\n    // Calculate perpendicular distance from point to line segment (in meters)\n    perpendicularDistance(point, lineStart, lineEnd) {\n        const [lon0, lat0] = point;\n        const [lon1, lat1] = lineStart;\n        const [lon2, lat2] = lineEnd;\n        \n        // Calculate distance using cross product in lat/lng space\n        const dx = lon2 - lon1;\n        const dy = lat2 - lat1;\n        const d = Math.sqrt(dx * dx + dy * dy);\n        \n        if (d === 0) {\n            // Line start and end are the same, calculate distance to point\n            return this.haversineDistance([lon0, lat0], [lon1, lat1]);\n        }\n        \n        // Calculate perpendicular distance\n        const t = Math.max(0, Math.min(1, ((lon0 - lon1) * dx + (lat0 - lat1) * dy) / (d * d)));\n        const projLon = lon1 + t * dx;\n        const projLat = lat1 + t * dy;\n        \n        return this.haversineDistance([lon0, lat0], [projLon, projLat]);\n    }\n\n    // Haversine distance between two points (in meters)\n    haversineDistance(point1, point2) {\n        const R = 6371000; // Earth radius in meters\n        const [lon1, lat1] = point1;\n        const [lon2, lat2] = point2;\n        \n        const dLat = (lat2 - lat1) * Math.PI / 180;\n        const dLon = (lon2 - lon1) * Math.PI / 180;\n        \n        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n                  Math.sin(dLon / 2) * Math.sin(dLon / 2);\n        \n        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        return R * c;\n    }\n\n    // Simplify geometry using Douglas-Peucker\n    simplifyGeometry() {\n        if (!this.currentPreviewSequence || !this.editableLayers || this.editableLayers.length === 0) {\n            alert('No geometry to simplify. Please open a preview first.');\n            return;\n        }\n        \n        if (!this.previewEditMode) {\n            alert('Please enable edit mode first.');\n            return;\n        }\n        \n        const toleranceInput = document.getElementById('toleranceInput');\n        const tolerance = parseFloat(toleranceInput.value) || 5; // Default 5 meters\n        \n        if (tolerance <= 0) {\n            alert('Tolerance must be greater than 0.');\n            return;\n        }\n        \n        // Save state before simplifying\n        this.saveStateToHistory();\n        \n        let totalNodesBefore = 0;\n        let totalNodesAfter = 0;\n        \n        // Simplify each layer - ONLY GPS trace layers (blue ways), not OSM data\n        const gpsTraceLayers = this.editableLayers.filter(layer => layer._isGpsTrace && (layer instanceof L.Polyline || layer instanceof L.Polygon));\n        \n        if (gpsTraceLayers.length === 0) {\n            alert('No GPS trace geometry found to simplify. Simplify only works on GPS trace (blue lines), not OSM data.');\n            return;\n        }\n        \n        gpsTraceLayers.forEach((layer) => {\n                const latlngs = this.flattenLatLngs(layer.getLatLngs());\n                \n                if (latlngs.length <= 2) {\n                    return; // Can't simplify lines with 2 or fewer points\n                }\n                \n                totalNodesBefore += latlngs.length;\n                \n                // Convert to [lng, lat] format for algorithm\n                const points = latlngs.map(ll => {\n                    if (ll instanceof L.LatLng) {\n                        return [ll.lng, ll.lat];\n                    } else if (Array.isArray(ll)) {\n                        // Assume [lat, lng] format\n                        return [ll[1] || ll[0], ll[0] || ll[1]];\n                    }\n                    return [ll.lng, ll.lat];\n                });\n                \n                // Apply Douglas-Peucker\n                const simplified = this.douglasPeucker(points, tolerance);\n                \n                totalNodesAfter += simplified.length;\n                \n                // Convert back to LatLng objects\n                const simplifiedLatLngs = simplified.map(pt => L.latLng(pt[1], pt[0]));\n                \n                // Update the layer\n                if (layer instanceof L.Polygon) {\n                    layer.setLatLngs([simplifiedLatLngs]);\n                } else {\n                    layer.setLatLngs(simplifiedLatLngs);\n                }\n                \n                // Update vertex markers\n                this.updateVertexMarkers(layer, simplifiedLatLngs);\n            }\n        });\n        \n        const reduction = totalNodesBefore > 0 ? ((totalNodesBefore - totalNodesAfter) / totalNodesBefore * 100).toFixed(1) : 0;\n        alert(`âœ… Geometry simplified!\\n\\nNodes before: ${totalNodesBefore}\\nNodes after: ${totalNodesAfter}\\nReduction: ${reduction}%`);\n    }\n\n    savePreviewEdits() {\n        if (!this.currentPreviewSequence) {\n            alert('Error: No sequence loaded in preview.');\n            return;\n        }\n        \n        // Check if we have editable layers - if not, try to extract from map\n        if (!this.editableLayers || this.editableLayers.length === 0) {\n            console.warn('No editable layers found, trying to extract from map...');\n            this.editableLayers = [];\n            this.map.eachLayer((layer) => {\n                if ((layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Marker) && \n                    !(layer instanceof L.TileLayer) && \n                    !layer._isVertexMarker &&\n                    !layer._isDeleteButton) {\n                    this.editableLayers.push(layer);\n                }\n            });\n            \n            if (this.editableLayers.length === 0) {\n                alert('Error: No geometry found to save.\\n\\nPlease make sure:\\n1. You have features visible in the preview\\n2. Edit mode is enabled\\n3. You have made some edits');\n                return;\n            }\n            console.log('Found', this.editableLayers.length, 'layers from map');\n        }\n        \n        console.log('Saving edits from', this.editableLayers.length, 'layers');\n        \n        // Convert edited layers back to GeoJSON features\n        const editedFeatures = [];\n        this.editableLayers.forEach((layer, idx) => {\n            let geometry = null;\n            \n            try {\n                if (layer instanceof L.Polyline) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                // Try to detect format: if first value > 90, it's probably lng\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]]; // [lng, lat]\n                                } else {\n                                    return [ll[1], ll[0]]; // [lat, lng] -> [lng, lat]\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        if (coords.length >= 2) { // LineString needs at least 2 points\n                            geometry = {\n                                type: 'LineString',\n                                coordinates: coords\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Polygon) {\n                    const latlngs = layer.getLatLngs();\n                    const flatLatlngs = this.flattenLatLngs(latlngs);\n                    \n                    if (flatLatlngs.length > 0) {\n                        const coords = flatLatlngs.map(ll => {\n                            if (ll instanceof L.LatLng || (ll.lat !== undefined && ll.lng !== undefined)) {\n                                return [ll.lng, ll.lat];\n                            } else if (Array.isArray(ll) && ll.length >= 2) {\n                                if (Math.abs(ll[0]) > 90) {\n                                    return [ll[0], ll[1]];\n                                } else {\n                                    return [ll[1], ll[0]];\n                                }\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && coord[0] !== undefined && coord[1] !== undefined);\n                        \n                        // Close the polygon\n                        if (coords.length > 0 && (coords[0][0] !== coords[coords.length - 1][0] || coords[0][1] !== coords[coords.length - 1][1])) {\n                            coords.push(coords[0]);\n                        }\n                        \n                        if (coords.length >= 4) { // Polygon needs at least 4 points (closed ring)\n                            geometry = {\n                                type: 'Polygon',\n                                coordinates: [coords]\n                            };\n                        }\n                    }\n                } else if (layer instanceof L.Marker) {\n                    const latlng = layer.getLatLng();\n                    if (latlng && latlng.lat !== undefined && latlng.lng !== undefined) {\n                        geometry = {\n                            type: 'Point',\n                            coordinates: [latlng.lng, latlng.lat]\n                        };\n                    }\n                }\n                \n                if (geometry) {\n                    // Preserve original feature properties\n                    const originalFeature = layer.feature || { properties: {} };\n                    editedFeatures.push({\n                        type: 'Feature',\n                        geometry: geometry,\n                        properties: originalFeature.properties || {}\n                    });\n                    console.log(`Layer ${idx}: Converted to ${geometry.type} with ${geometry.coordinates.length} coordinates`);\n                } else {\n                    console.warn(`Layer ${idx}: Could not extract valid geometry`);\n                }\n            } catch (error) {\n                console.error(`Error processing layer ${idx}:`, error);\n            }\n        });\n        \n        if (editedFeatures.length === 0) {\n            alert('Error: Could not extract any valid features from the edited layers.\\n\\nPlease try:\\n1. Make sure edit mode is enabled\\n2. Make sure you have geometry visible on the map\\n3. Try reverting and re-editing');\n            return;\n        }\n        \n        console.log('Successfully saved', editedFeatures.length, 'features');\n        \n        // Update sequence features\n        this.currentPreviewSequence.features = editedFeatures;\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = editedFeatures;\n            // Also update stats\n            const stats = this.calculateStats(editedFeatures);\n            this.sequences[sequenceIndex].featureCount = stats.features;\n            this.sequences[sequenceIndex].nodeCount = stats.nodes;\n            this.sequences[sequenceIndex].wayCount = stats.ways;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n        \n        // Update original for revert\n        this.originalPreviewFeatures = JSON.parse(JSON.stringify(editedFeatures));\n        \n        // Changes saved silently - no popup needed\n    }\n\n    revertPreviewEdits() {\n        if (!this.currentPreviewSequence || !this.originalPreviewFeatures) return;\n        \n        const confirmed = confirm('Are you sure you want to revert all changes? This will restore the original geometry.');\n        if (!confirmed) return;\n        \n        // Restore original features\n        this.currentPreviewSequence.features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = JSON.parse(JSON.stringify(this.originalPreviewFeatures));\n        }\n        \n        // Re-render the preview\n        this.previewSequence(this.currentPreviewSequence.id);\n        \n        alert('âœ… Changes reverted successfully!');\n    }\n\n    closePreview() {\n        // Disable edit mode if active\n        if (this.previewEditMode) {\n            this.toggleEditMode();\n        }\n        \n        // Clear undo/redo history when closing preview\n        this.editHistory = [];\n        this.currentHistoryIndex = -1;\n        \n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        this.previewEditMode = false;\n        this.originalPreviewFeatures = null;\n        this.editableLayers = [];\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    updateHighwayTag(value) {\n        if (!this.currentPreviewSequence) return;\n        \n        // Update highway property for all features in the sequence\n        this.currentPreviewSequence.features.forEach(feature => {\n            if (feature.properties) {\n                feature.properties.highway = value;\n            } else {\n                feature.properties = { highway: value };\n            }\n        });\n        \n        // Update the sequence in the main sequences array\n        const sequenceIndex = this.sequences.findIndex(s => s.id === this.currentPreviewSequence.id);\n        if (sequenceIndex >= 0) {\n            this.sequences[sequenceIndex].features = this.currentPreviewSequence.features;\n        }\n        \n        // Save to storage\n        this.saveToStorage();\n    }\n\n    async exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            // If edit mode is enabled and there are editable layers, save edits first\n            if (this.previewEditMode && this.editableLayers && this.editableLayers.length > 0) {\n                // Save edits automatically before exporting\n                this.savePreviewEdits();\n            }\n            \n            // Export uses the edited geometry (saved above or from previous save)\n            await this.exportToJOSM(this.currentPreviewSequence.id);\n            // Don't close preview automatically - let user see the confirmation\n            // this.closePreview();\n        }\n    }\n\n    updateSummary() {\n        const summaryInfo = document.getElementById('summaryInfo');\n        if (!summaryInfo) return;\n\n        const total = this.sequences.length;\n        const active = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n        const skipped = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const done = this.sequences.filter(seq => seq.status === 'done').length;\n\n        summaryInfo.innerHTML = `\n            <span>Total Sequences: ${total}</span>\n            <span>Active: ${active}</span>\n            <span>Skipped: ${skipped}</span>\n            <span>Done: ${done}</span>\n        `;\n    }\n\n    async saveToStorage() {\n        try {\n            // Save id and status to IndexedDB\n            const taskData = {\n                sequences: this.sequences.map(seq => ({\n                    id: seq.id,\n                    status: seq.status\n                })),\n                currentIndex: this.currentIndex,\n                currentView: this.currentView\n            };\n            \n            await storageManager.saveTaskData(taskData);\n            \n            // Also save geojsonData to IndexedDB for full functionality\n            if (this.geojsonData) {\n                await storageManager.saveGeoJSONData(this.geojsonData);\n            }\n        } catch (error) {\n            console.error('Error saving to storage:', error);\n        }\n    }\n\n    exportAllToCSV() {\n        const allSequences = this.getAllSequences();\n        \n        if (allSequences.length === 0) {\n            alert('No sequences to export.');\n            return;\n        }\n\n        // Create CSV content\n        const headers = ['Sequence ID', 'Status'];\n        const rows = allSequences.map(seq => {\n            const status = seq.status || 'Active (Blank)';\n            // Escape commas and quotes in sequence ID\n            const sequenceId = String(seq.id).replace(/\"/g, '\"\"');\n            return `\"${sequenceId}\",\"${status}\"`;\n        });\n\n        const csvContent = [\n            headers.join(','),\n            ...rows\n        ].join('\\n');\n\n        // Create blob and download\n        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n        const link = document.createElement('a');\n        const url = URL.createObjectURL(blob);\n        \n        // Generate filename with timestamp\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n        const filename = `OSMAGIC_Tasks_Export_${timestamp}.csv`;\n        \n        link.setAttribute('href', url);\n        link.setAttribute('download', filename);\n        link.style.visibility = 'hidden';\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        \n        // Show success message\n        alert(`âœ… Successfully exported ${allSequences.length} sequences to ${filename}`);\n    }\n\n    async clearAllData() {\n        // Show confirmation dialog\n        const confirmed = confirm(\n            'âš ï¸ WARNING: This will permanently delete ALL data including:\\n\\n' +\n            'â€¢ All sequence IDs\\n' +\n            'â€¢ All status information\\n' +\n            'â€¢ All GeoJSON/GPX/CSV data\\n' +\n            'â€¢ All progress and metadata\\n\\n' +\n            'This action CANNOT be undone!\\n\\n' +\n            'Are you sure you want to clear all data?'\n        );\n\n        if (!confirmed) {\n            return;\n        }\n\n        try {\n            // Clear IndexedDB\n            await storageManager.clearAll();\n\n            // Reset all state\n            this.geojsonData = null;\n            this.sequences = [];\n            this.currentIndex = 0;\n            this.currentView = 'all';\n            this.navigatingToSequenceId = null;\n            this.currentPreviewSequence = null;\n\n            // Clear file input\n            const fileInput = document.getElementById('fileInput');\n            if (fileInput) {\n                fileInput.value = '';\n            }\n\n            // Clear file info\n            const fileInfo = document.getElementById('fileInfo');\n            if (fileInfo) {\n                fileInfo.textContent = '';\n            }\n\n            // Reset tab buttons\n            document.querySelectorAll('.tab-btn').forEach(btn => {\n                if (btn.dataset.view === 'all') {\n                    btn.classList.add('active');\n                } else {\n                    btn.classList.remove('active');\n                }\n            });\n\n            // Update UI\n            this.renderCurrentTask();\n            this.updateSummary();\n\n            // Show success message\n            alert('âœ… All data has been cleared successfully!');\n        } catch (error) {\n            console.error('Error clearing data:', error);\n            alert('âŒ Error clearing data. Please try again or check the console for details.');\n        }\n    }\n\n    async loadFromStorage() {\n        try {\n            // Load task data from IndexedDB\n            const taskData = await storageManager.loadTaskData();\n            if (!taskData) return;\n\n            // Load geojsonData from IndexedDB\n            this.geojsonData = await storageManager.loadGeoJSONData();\n\n            if (taskData.sequences && Array.isArray(taskData.sequences)) {\n                // Restore only id and status from storage\n                // If geojsonData exists, recalculate stats from features\n                if (this.geojsonData && this.geojsonData.features) {\n                    // Recalculate stats from geojsonData\n                    const sequenceMap = new Map();\n                    \n                    this.geojsonData.features.forEach((feature) => {\n                        const sequenceId = String(\n                            feature.properties?.sequence_id || \n                            feature.properties?.sequenceId || \n                            feature.properties?.sequence || \n                            feature.properties?.id ||\n                            feature.properties?.seq ||\n                            `sequence_${feature.properties?.id || Math.random().toString(36).substr(2, 9)}`\n                        );\n\n                        if (!sequenceMap.has(sequenceId)) {\n                            sequenceMap.set(sequenceId, {\n                                id: sequenceId,\n                                features: []\n                            });\n                        }\n\n                        sequenceMap.get(sequenceId).features.push(feature);\n                    });\n\n                    // Restore status from saved data and calculate stats\n                    const savedStatusMap = new Map();\n                    taskData.sequences.forEach(seq => {\n                        savedStatusMap.set(String(seq.id), seq.status);\n                    });\n\n                    this.sequences = Array.from(sequenceMap.values()).map(seq => {\n                        const stats = this.calculateStats(seq.features);\n                        return {\n                            ...seq,\n                            status: savedStatusMap.get(String(seq.id)) || '',\n                            featureCount: stats.features,\n                            nodeCount: stats.nodes,\n                            wayCount: stats.ways,\n                            date: new Date().toLocaleDateString()\n                        };\n                    });\n\n                    // Sort by sequence ID\n                    this.sequences.sort((a, b) => {\n                        const aNum = parseInt(a.id);\n                        const bNum = parseInt(b.id);\n                        if (!isNaN(aNum) && !isNaN(bNum)) {\n                            return aNum - bNum;\n                        }\n                        return a.id.localeCompare(b.id);\n                    });\n                } else {\n                    // No geojsonData available, just restore basic structure\n                    this.sequences = taskData.sequences.map(seq => ({\n                        id: seq.id,\n                        status: seq.status || '',\n                        features: [],\n                        featureCount: 0,\n                        nodeCount: 0,\n                        wayCount: 0,\n                        date: new Date().toLocaleDateString()\n                    }));\n                }\n                \n                this.currentIndex = taskData.currentIndex || 0;\n                this.currentView = taskData.currentView || 'all';\n                \n                // Update tab buttons to reflect current view\n                document.querySelectorAll('.tab-btn').forEach(btn => {\n                    if (btn.dataset.view === this.currentView) {\n                        btn.classList.add('active');\n                    } else {\n                        btn.classList.remove('active');\n                    }\n                });\n                \n                if (this.sequences.length > 0) {\n                    this.renderCurrentTask();\n                    this.updateSummary();\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from storage:', error);\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n",
        "index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css\" />\n    <link rel=\"stylesheet\" href=\"styles.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js\"></script>\n    <script src=\"https://unpkg.com/leaflet-editable@0.7.0/dist/leaflet-editable.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Convert GPS traces (GeoJSON/GPX/CSV) to JOSM format - One sequence at a time</p>\n                </div>\n                <button id=\"clearAllBtn\" class=\"btn-clear-all\" onclick=\"taskManager.clearAllData()\" title=\"Clear all stored data\">\n                    ðŸ—‘ï¸ Clear All Data\n                </button>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload GPS Trace File</h3>\n                <div class=\"file-upload\">\n                    <input type=\"file\" id=\"fileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                    <label for=\"fileInput\" class=\"upload-button\">\n                        Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                    </label>\n                </div>\n                <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                    <strong>Supported formats:</strong>\n                    <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                        <li>GeoJSON (.geojson, .json)</li>\n                        <li>GPX (.gpx)</li>\n                        <li>CSV (.csv) - with lat/lon columns</li>\n                    </ul>\n                </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"task-section\">\n            <div class=\"task-header\">\n                <h3>ðŸ“Š Current Task</h3>\n                <div class=\"task-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" disabled>\n                        â† Previous\n                    </button>\n                    <span id=\"taskCounter\" class=\"task-counter\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" disabled>\n                        Next â†’\n                    </button>\n                </div>\n            </div>\n            \n            <div class=\"task-tabs\">\n                <button class=\"tab-btn active\" data-view=\"all\" onclick=\"taskManager.switchView('all')\">\n                    All Tasks\n                </button>\n                <button class=\"tab-btn\" data-view=\"active\" onclick=\"taskManager.switchView('active')\">\n                    Active\n                </button>\n                <button class=\"tab-btn\" data-view=\"done\" onclick=\"taskManager.switchView('done')\">\n                    Done\n                </button>\n                <button class=\"tab-btn\" data-view=\"skipped\" onclick=\"taskManager.switchView('skipped')\">\n                    Skipped\n                </button>\n            </div>\n\n            <div class=\"task-display\" id=\"taskDisplay\">\n                <div class=\"empty-state\">\n                    <p>Upload a GeoJSON file to begin</p>\n                </div>\n            </div>\n\n            <div class=\"task-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Active: 0</span>\n                    <span>Skipped: 0</span>\n                    <span>Done: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ OSMAGIC Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div class=\"highway-selector\">\n                    <span class=\"highway-label\">highway</span>\n                    <span class=\"highway-equals\">=</span>\n                    <select id=\"highwaySelect\" class=\"highway-value\" onchange=\"taskManager.updateHighwayTag(this.value)\">\n                        <option value=\"unclassified\">unclassified</option>\n                        <option value=\"residential\">residential</option>\n                        <option value=\"service\">service</option>\n                        <option value=\"driveway\">driveway</option>\n                        <option value=\"track\">track</option>\n                        <option value=\"path\">path</option>\n                        <option value=\"footway\">footway</option>\n                        <option value=\"cycleway\">cycleway</option>\n                        <option value=\"primary\">primary</option>\n                        <option value=\"secondary\">secondary</option>\n                        <option value=\"tertiary\">tertiary</option>\n                        <option value=\"trunk\">trunk</option>\n                        <option value=\"motorway\">motorway</option>\n                    </select>\n                </div>\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <div class=\"preview-mode-controls\">\n                        <button id=\"toggleEditModeBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.toggleEditMode()\">\n                            âœï¸ Enable Edit Mode\n                        </button>\n                        <button id=\"undoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.undo()\" style=\"display: none;\" disabled>\n                            â†¶ Undo\n                        </button>\n                        <button id=\"redoBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.redo()\" style=\"display: none;\" disabled>\n                            â†· Redo\n                        </button>\n                        <button id=\"simplifyBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.simplifyGeometry()\" style=\"display: none;\">\n                            ðŸ“‰ Simplify Geometry\n                        </button>\n                        <input type=\"number\" id=\"toleranceInput\" placeholder=\"Tolerance (m)\" value=\"5\" min=\"0.1\" step=\"0.1\" style=\"display: none; width: 120px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;\">\n                        <button id=\"saveEditsBtn\" class=\"btn btn-primary\" onclick=\"taskManager.savePreviewEdits()\" style=\"display: none;\">\n                            ðŸ’¾ Save Changes\n                        </button>\n                        <button id=\"revertEditsBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.revertPreviewEdits()\" style=\"display: none;\">\n                            â†¶ Revert Changes\n                        </button>\n                    </div>\n                    <div class=\"preview-export-controls\">\n                        <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                            ðŸ“¥ Export to JOSM\n                        </button>\n                        <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                            Close\n                        </button>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage.js\"></script>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n\n",
        "server.py": "#!/usr/bin/env python3\n\"\"\"\nSimple HTTP server to run the Task Manager locally\nRun this file and then open http://localhost:8000 in your browser\n\"\"\"\n\nimport http.server\nimport socketserver\nimport webbrowser\nimport os\nimport json\nimport urllib.parse\nfrom datetime import datetime\nimport tempfile\nimport shutil\n\nPORT = 8000\nEXPORT_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'exports')\n\n# Create exports directory if it doesn't exist\nif not os.path.exists(EXPORT_DIR):\n    os.makedirs(EXPORT_DIR)\n\nclass MyHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):\n    def end_headers(self):\n        # Add CORS headers to allow requests from the web app\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')\n        self.send_header('Pragma', 'no-cache')\n        self.send_header('Expires', '0')\n        super().end_headers()\n    \n    def do_OPTIONS(self):\n        # Handle CORS preflight requests\n        self.send_response(200)\n        self.end_headers()\n    \n    def do_POST(self):\n        if self.path == '/export':\n            # Handle OSM file export request\n            try:\n                content_length = int(self.headers['Content-Length'])\n                post_data = self.rfile.read(content_length)\n                \n                # Parse JSON request\n                data = json.loads(post_data.decode('utf-8'))\n                sequence_id = data.get('sequenceId', 'unknown')\n                osm_xml = data.get('osmXml', '')\n                \n                if not osm_xml:\n                    self.send_response(400)\n                    self.send_header('Content-Type', 'application/json')\n                    self.end_headers()\n                    self.wfile.write(json.dumps({'error': 'No OSM XML provided'}).encode())\n                    return\n                \n                # Save OSM file\n                filename = f'sequence_{sequence_id}.osm'\n                filepath = os.path.join(EXPORT_DIR, filename)\n                \n                with open(filepath, 'w', encoding='utf-8') as f:\n                    f.write(osm_xml)\n                \n                # Return URL to the file\n                file_url = f'http://localhost:{PORT}/exports/{filename}'\n                \n                self.send_response(200)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({\n                    'success': True,\n                    'url': file_url,\n                    'filename': filename\n                }).encode())\n                \n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Exported: {filename}\")\n                \n            except Exception as e:\n                self.send_response(500)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps({'error': str(e)}).encode())\n                print(f\"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Export error: {e}\")\n        else:\n            self.send_response(404)\n            self.end_headers()\n    \n    def do_GET(self):\n        # Serve static files and exported OSM files\n        if self.path.startswith('/exports/'):\n            # Serve exported OSM files\n            filename = self.path[9:]  # Remove '/exports/' prefix\n            filepath = os.path.join(EXPORT_DIR, filename)\n            \n            if os.path.exists(filepath) and os.path.isfile(filepath):\n                self.send_response(200)\n                self.send_header('Content-Type', 'application/xml')\n                self.send_header('Content-Disposition', f'inline; filename=\"{filename}\"')\n                self.end_headers()\n                \n                with open(filepath, 'rb') as f:\n                    shutil.copyfileobj(f, self.wfile)\n            else:\n                self.send_response(404)\n                self.end_headers()\n        else:\n            # Serve regular static files\n            super().do_GET()\n\ndef main():\n    # Change to the directory where this script is located\n    os.chdir(os.path.dirname(os.path.abspath(__file__)))\n    \n    Handler = MyHTTPRequestHandler\n    \n    with socketserver.TCPServer((\"\", PORT), Handler) as httpd:\n        url = f\"http://localhost:{PORT}\"\n        print(\"=\" * 60)\n        print(f\"Task Manager Server is running!\")\n        print(f\"Open your browser and go to: {url}\")\n        print(f\"Export directory: {EXPORT_DIR}\")\n        print(\"=\" * 60)\n        print(\"Press Ctrl+C to stop the server\")\n        print(\"=\" * 60)\n        \n        # Try to open browser automatically\n        try:\n            webbrowser.open(url)\n        except:\n            pass\n        \n        try:\n            httpd.serve_forever()\n        except KeyboardInterrupt:\n            print(\"\\n\\nServer stopped.\")\n\nif __name__ == \"__main__\":\n    main()\n\n",
        "styles.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #ffffff;\n    min-height: 100vh;\n    color: #000000;\n    padding: 20px;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n}\n\n.header {\n    background: #ffffff;\n    padding: 30px;\n    border-radius: 15px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.header > div {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    flex-wrap: wrap;\n    gap: 15px;\n}\n\n.header > div > div:first-child {\n    text-align: center;\n    flex: 1;\n}\n\n.header h1 {\n    color: #000000;\n    margin-bottom: 10px;\n    font-size: 2.5em;\n}\n\n.header p {\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: #ffffff;\n    padding: 25px;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 12px 24px;\n    background: #000000;\n    color: white;\n    border-radius: 8px;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    font-weight: 500;\n    font-size: 1em;\n    border: 2px solid #000000;\n}\n\n.upload-button:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.file-info {\n    margin-top: 15px;\n    padding: 12px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    font-size: 0.9em;\n    color: #000000;\n    border-left: 4px solid #000000;\n}\n\n.task-section {\n    background: #ffffff;\n    border-radius: 15px;\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n    border: 1px solid #e0e0e0;\n    overflow: hidden;\n}\n\n.task-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.task-tabs {\n    display: flex;\n    gap: 0;\n    border-bottom: 2px solid #e0e0e0;\n    background: #ffffff;\n    padding: 0 25px;\n}\n\n.tab-btn {\n    padding: 12px 24px;\n    background: transparent;\n    color: #666666;\n    border: none;\n    border-bottom: 3px solid transparent;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    margin-bottom: -2px;\n}\n\n.tab-btn:hover {\n    color: #000000;\n    background: #f5f5f5;\n}\n\n.tab-btn.active {\n    color: #000000;\n    border-bottom-color: #000000;\n    font-weight: 600;\n}\n\n.task-header h3 {\n    color: #000000;\n    font-size: 1.3em;\n}\n\n.task-controls {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.task-counter {\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n    min-width: 150px;\n    text-align: center;\n}\n\n.btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-primary {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-secondary {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-clear-all {\n    padding: 10px 20px;\n    background: #dc3545;\n    color: white;\n    border: 2px solid #dc3545;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n    white-space: nowrap;\n}\n\n.btn-clear-all:hover {\n    background: #c82333;\n    border-color: #c82333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    transform: none;\n}\n\n.task-display {\n    padding: 30px;\n    min-height: 400px;\n}\n\n.empty-state {\n    text-align: center;\n    padding: 60px 20px;\n    color: #666666;\n    font-size: 1.1em;\n}\n\n.task-card {\n    background: white;\n    border: 2px solid #e0e0e0;\n    border-radius: 12px;\n    padding: 25px;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n}\n\n.task-id {\n    font-size: 1.8em;\n    font-weight: 700;\n    color: #000000;\n    margin-bottom: 20px;\n    padding-bottom: 15px;\n    border-bottom: 2px solid #e0e0e0;\n}\n\n.task-id-label {\n    font-size: 0.6em;\n    font-weight: 400;\n    color: #666666;\n    display: block;\n    margin-bottom: 5px;\n}\n\n.task-details {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n    gap: 20px;\n    margin-bottom: 25px;\n}\n\n.detail-item {\n    padding: 15px;\n    background: #f8f9fa;\n    border-radius: 8px;\n}\n\n.detail-label {\n    font-size: 0.85em;\n    color: #666666;\n    margin-bottom: 5px;\n    font-weight: 500;\n}\n\n.detail-value {\n    font-size: 1.3em;\n    font-weight: 600;\n    color: #000000;\n}\n\n.status-section {\n    margin-bottom: 25px;\n}\n\n.status-label {\n    font-weight: 600;\n    color: #000000;\n    margin-bottom: 10px;\n    display: block;\n}\n\n.status-dropdown {\n    width: 100%;\n    padding: 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 1em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n}\n\n.status-dropdown:hover {\n    border-color: #000000;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n.action-buttons {\n    display: flex;\n    gap: 15px;\n    flex-wrap: wrap;\n}\n\n.action-btn {\n    flex: 1;\n    min-width: 150px;\n    padding: 12px 20px;\n    border: none;\n    border-radius: 8px;\n    cursor: pointer;\n    font-size: 0.95em;\n    font-weight: 500;\n    transition: all 0.3s ease;\n}\n\n.btn-export {\n    background: #000000;\n    color: white;\n    border: 2px solid #000000;\n}\n\n.btn-export:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.btn-preview {\n    background: #666666;\n    color: white;\n    border: 2px solid #666666;\n}\n\n.btn-preview:hover {\n    background: #333333;\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.task-footer {\n    padding: 20px 25px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    flex-wrap: wrap;\n    font-size: 0.95em;\n    color: #000000;\n}\n\n.summary-info span {\n    font-weight: 600;\n    padding: 8px 15px;\n    background: white;\n    border-radius: 6px;\n    border: 1px solid #000000;\n    color: #000000;\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 15px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px 25px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 15px 15px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #000000;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #666666;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #000000;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.highway-selector {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 12px 15px;\n    background: #f8f9fa;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    margin-bottom: 15px;\n    font-size: 1em;\n}\n\n.highway-label {\n    font-weight: 600;\n    color: #000000;\n    padding: 6px 12px;\n    background: #ffffff;\n    border: 1px solid #d0d0d0;\n    border-radius: 4px;\n}\n\n.highway-equals {\n    font-weight: 600;\n    color: #666666;\n    font-size: 1.2em;\n}\n\n.highway-value {\n    padding: 6px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    background: #ffffff;\n    color: #000000;\n    font-size: 0.95em;\n    cursor: pointer;\n    min-width: 150px;\n    transition: all 0.2s;\n}\n\n.highway-value:hover {\n    border-color: #0066ff;\n}\n\n.highway-value:focus {\n    outline: none;\n    border-color: #0066ff;\n    box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.1);\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 2px solid #e0e0e0;\n    border-radius: 10px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 15px;\n    justify-content: space-between;\n    align-items: center;\n    padding-top: 15px;\n    border-top: 2px solid #e0e0e0;\n    flex-wrap: wrap;\n}\n\n.preview-mode-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n.preview-export-controls {\n    display: flex;\n    gap: 10px;\n    flex-wrap: wrap;\n}\n\n#toleranceInput {\n    font-size: 0.9em;\n}\n\n#toleranceInput:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.delete-node-btn {\n    background: transparent;\n    border: none;\n    pointer-events: all;\n}\n\n.delete-node-icon {\n    width: 20px;\n    height: 20px;\n    background: #dc3545;\n    color: white;\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 16px;\n    font-weight: bold;\n    cursor: pointer;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    transition: all 0.2s;\n}\n\n.delete-node-icon:hover {\n    background: #c82333;\n    transform: scale(1.2);\n}\n\n.vertex-marker {\n    background: transparent;\n    border: none;\n}\n\n.vertex-handle {\n    width: 12px;\n    height: 12px;\n    background: #ff0000;\n    border: 2px solid #ffffff;\n    border-radius: 50%;\n    cursor: move;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n}\n\n.vertex-handle:hover {\n    background: #cc0000;\n    transform: scale(1.2);\n}\n\n@media (max-width: 768px) {\n    .header h1 {\n        font-size: 2em;\n    }\n\n    .task-header {\n        flex-direction: column;\n        gap: 15px;\n        align-items: stretch;\n    }\n\n    .task-controls {\n        justify-content: center;\n    }\n\n    .task-details {\n        grid-template-columns: 1fr;\n    }\n\n    .action-buttons {\n        flex-direction: column;\n    }\n\n    .action-btn {\n        width: 100%;\n    }\n\n    .summary-info {\n        flex-direction: column;\n        gap: 10px;\n    }\n\n    .modal-content {\n        width: 95%;\n        margin: 5% auto;\n    }\n\n    .preview-map {\n        height: 400px;\n        min-height: 400px;\n    }\n\n    #previewMap {\n        min-height: 400px;\n    }\n\n    .preview-actions {\n        flex-direction: column;\n    }\n\n    .preview-actions .btn {\n        width: 100%;\n    }\n}\n\n/* All Tasks List View */\n.all-tasks-list {\n    padding: 20px;\n}\n\n.all-tasks-list h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n    gap: 10px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-id-item {\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    text-align: center;\n    font-weight: 600;\n    color: #000000;\n    transition: all 0.2s ease;\n}\n\n.sequence-id-item.clickable {\n    cursor: pointer;\n}\n\n.sequence-id-item.clickable:hover {\n    background: #000000;\n    color: #ffffff;\n    transform: translateY(-2px);\n    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n}\n\n.search-input {\n    width: 100%;\n    padding: 10px 15px;\n    padding-left: 40px;\n    border: 2px solid #e0e0e0;\n    border-radius: 8px;\n    font-size: 0.95em;\n    transition: all 0.3s ease;\n    background: #ffffff;\n    color: #000000;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1);\n}\n\n.search-input::placeholder {\n    color: #999999;\n}\n\n/* Simple View (Skipped/Done) */\n.simple-list-view {\n    padding: 20px;\n}\n\n.simple-list-view h4 {\n    color: #000000;\n    margin-bottom: 20px;\n    font-size: 1.2em;\n    font-weight: 600;\n}\n\n.sequence-list-with-status {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 15px;\n    max-height: 600px;\n    overflow-y: auto;\n    padding: 10px;\n    background: #f5f5f5;\n    border-radius: 8px;\n    border: 1px solid #e0e0e0;\n}\n\n.sequence-item-with-status {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n    padding: 12px;\n    background: #ffffff;\n    border: 1px solid #000000;\n    border-radius: 6px;\n    transition: all 0.2s ease;\n}\n\n.sequence-item-with-status:hover {\n    background: #f5f5f5;\n}\n\n.sequence-item-with-status.highlighted {\n    background: #ffffcc !important;\n    border-color: #000000 !important;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    transition: background-color 0.3s ease, box-shadow 0.3s ease;\n}\n\n.sequence-id-display {\n    flex: 1;\n    font-weight: 600;\n    color: #000000;\n    font-size: 1em;\n}\n\n.status-dropdown-inline {\n    padding: 8px 12px;\n    border: 2px solid #e0e0e0;\n    border-radius: 6px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.3s ease;\n    min-width: 150px;\n}\n\n.status-dropdown-inline:hover {\n    border-color: #000000;\n}\n\n.status-dropdown-inline:focus {\n    outline: none;\n    border-color: #000000;\n    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.2);\n}\n\n",
        "storage.js": "// IndexedDB Storage Manager for OSMAGIC Task Manager\nclass StorageManager {\n    constructor() {\n        this.dbName = 'OSMAGIC_TaskManager';\n        this.dbVersion = 1;\n        this.db = null;\n    }\n\n    async init() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open(this.dbName, this.dbVersion);\n\n            request.onerror = () => {\n                console.error('IndexedDB error:', request.error);\n                reject(request.error);\n            };\n\n            request.onsuccess = () => {\n                this.db = request.result;\n                resolve(this.db);\n            };\n\n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n\n                // Create object stores if they don't exist\n                if (!db.objectStoreNames.contains('taskData')) {\n                    const taskStore = db.createObjectStore('taskData', { keyPath: 'id' });\n                    taskStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n\n                if (!db.objectStoreNames.contains('geojsonData')) {\n                    db.createObjectStore('geojsonData', { keyPath: 'id' });\n                }\n            };\n        });\n    }\n\n    async saveTaskData(data) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readwrite');\n            const store = transaction.objectStore('taskData');\n            \n            const taskData = {\n                id: 'main',\n                sequences: data.sequences,\n                currentIndex: data.currentIndex,\n                currentView: data.currentView || 'all',\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(taskData);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadTaskData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData'], 'readonly');\n            const store = transaction.objectStore('taskData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result || null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async saveGeoJSONData(geojsonData) {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readwrite');\n            const store = transaction.objectStore('geojsonData');\n            \n            const data = {\n                id: 'main',\n                geojson: geojsonData,\n                timestamp: new Date().toISOString()\n            };\n\n            const request = store.put(data);\n\n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async loadGeoJSONData() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['geojsonData'], 'readonly');\n            const store = transaction.objectStore('geojsonData');\n            const request = store.get('main');\n\n            request.onsuccess = () => {\n                resolve(request.result ? request.result.geojson : null);\n            };\n\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    async clearAll() {\n        if (!this.db) await this.init();\n\n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction(['taskData', 'geojsonData'], 'readwrite');\n            \n            const taskRequest = transaction.objectStore('taskData').clear();\n            const geoRequest = transaction.objectStore('geojsonData').clear();\n\n            transaction.oncomplete = () => resolve();\n            transaction.onerror = () => reject(transaction.error);\n        });\n    }\n}\n\n// Create global instance\nconst storageManager = new StorageManager();\n\n",
        "task-manager.js": "class TaskManager {\n    constructor() {\n        this.geojsonData = null;\n        this.sequences = [];\n        this.selectedSequences = new Set();\n        this.map = null;\n        this.currentPreviewSequence = null;\n        this.currentSequenceIndex = 0; // Track which sequence is currently displayed\n        \n        // Load cached data on page load (async)\n        this.loadFromCache();\n        \n        // Load and display file info\n        this.loadFileInfo();\n        \n        this.initializeEventListeners();\n    }\n\n\n\n    initializeEventListeners() {\n        const fileInput = document.getElementById('geojsonFileInput');\n\n        if (fileInput) {\n            fileInput.addEventListener('change', (e) => this.handleFileUpload(e));\n        }\n    }\n\n    handleFileUpload(event) {\n        const files = Array.from(event.target.files);\n        if (files.length === 0) return;\n\n        const fileInfo = document.getElementById('fileInfo');\n        if (fileInfo) {\n            fileInfo.textContent = `Loading ${files.length} file(s)...`;\n        }\n\n        // Process all files with progress tracking\n        const promises = files.map(file => {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = async (e) => {\n                    try {\n                        const fileName = file.name.toLowerCase();\n                        let geojson;\n\n                        // Detect file type and parse accordingly\n                        if (fileName.endsWith('.gpx')) {\n                            geojson = this.parseGPX(e.target.result);\n                        } else if (fileName.endsWith('.csv')) {\n                            // Use async CSV parsing for large files (> 100 rows)\n                            const lineCount = (e.target.result.match(/\\n/g) || []).length;\n                            if (lineCount > 100) {\n                                geojson = await this.parseCSVAsync(e.target.result, (progress) => {\n                                    if (fileInfo && files.length === 1) {\n                                        fileInfo.textContent = `Processing CSV: ${progress}%...`;\n                                    }\n                                });\n                            } else {\n                                geojson = this.parseCSV(e.target.result);\n                            }\n                        } else {\n                            // Assume GeoJSON\n                            geojson = JSON.parse(e.target.result);\n                        }\n\n                        resolve({ geojson, fileName: file.name });\n                    } catch (error) {\n                        reject({ error, fileName: file.name });\n                    }\n                };\n                reader.onerror = () => reject({ error: new Error('Failed to read file'), fileName: file.name });\n                reader.readAsText(file);\n            });\n        });\n\n        // Combine all files into one GeoJSON\n        Promise.allSettled(promises).then(async results => {\n            const newFeatures = [];\n            const errors = [];\n            let loadedCount = 0;\n\n            results.forEach((result, index) => {\n                if (result.status === 'fulfilled') {\n                    newFeatures.push(...result.value.geojson.features);\n                    loadedCount++;\n                } else {\n                    errors.push(`${result.reason.fileName}: ${result.reason.error.message}`);\n                }\n            });\n\n            if (newFeatures.length === 0) {\n                if (fileInfo) {\n                    fileInfo.textContent = `âœ— Error: No valid files loaded. ${errors.join('; ')}`;\n                }\n                return;\n            }\n\n            // Merge with existing cached data instead of replacing\n            const existingFeatures = this.geojsonData?.features || [];\n            const allFeatures = [...existingFeatures, ...newFeatures];\n\n            // Combine all features into one GeoJSON\n            const combinedGeoJSON = {\n                type: 'FeatureCollection',\n                features: allFeatures\n            };\n\n            this.geojsonData = combinedGeoJSON;\n            \n            // Process with progress indicator for large datasets\n            if (allFeatures.length > 50) {\n                if (fileInfo) {\n                    fileInfo.textContent = `Processing ${allFeatures.length} features...`;\n                }\n                await this.processGeoJSONAsync(combinedGeoJSON, (progress) => {\n                    if (fileInfo) {\n                        fileInfo.textContent = `Processing: ${progress}%...`;\n                    }\n                });\n            } else {\n                this.processGeoJSON(combinedGeoJSON);\n            }\n            \n            // Upload to server and save metadata to cache\n            this.uploadToServerAndSave().catch(console.error);\n            \n            const errorMsg = errors.length > 0 ? ` (${errors.length} error(s))` : '';\n            const totalFeatures = allFeatures.length;\n            const addedCount = newFeatures.length;\n            const fileInfoText = `âœ“ Loaded ${loadedCount} file(s)${errorMsg}: ${addedCount} features (Total: ${totalFeatures} features)`;\n            \n            if (fileInfo) {\n                fileInfo.textContent = fileInfoText;\n            }\n            \n            // Save file info to storage so it persists across pages\n            await storageManager.saveFileInfo(fileInfoText);\n            \n            const exportBtn = document.getElementById('exportAllBtn');\n            if (exportBtn) {\n                exportBtn.disabled = false;\n            }\n        });\n    }\n\n    parseGPX(gpxText) {\n        // Parse GPX XML to GeoJSON format\n        const parser = new DOMParser();\n        const xmlDoc = parser.parseFromString(gpxText, 'text/xml');\n        \n        const features = [];\n        \n        // Parse tracks\n        const tracks = xmlDoc.getElementsByTagName('trk');\n        for (const track of tracks) {\n            const segments = track.getElementsByTagName('trkseg');\n            for (const segment of segments) {\n                const points = segment.getElementsByTagName('trkpt');\n                const coordinates = [];\n                \n                for (const point of points) {\n                    const lat = parseFloat(point.getAttribute('lat'));\n                    const lon = parseFloat(point.getAttribute('lon'));\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        coordinates.push([lon, lat]);\n                    }\n                }\n                \n                if (coordinates.length > 0) {\n                    features.push({\n                        type: 'Feature',\n                        geometry: {\n                            type: 'LineString',\n                            coordinates: coordinates\n                        },\n                        properties: {\n                            // Try to get sequence ID from track name or metadata\n                            sequence_id: this.extractSequenceIdFromGPX(track) || `gpx_track_${features.length + 1}`\n                        }\n                    });\n                }\n            }\n        }\n        \n        // Parse routes\n        const routes = xmlDoc.getElementsByTagName('rte');\n        for (const route of routes) {\n            const points = route.getElementsByTagName('rtept');\n            const coordinates = [];\n            \n            for (const point of points) {\n                const lat = parseFloat(point.getAttribute('lat'));\n                const lon = parseFloat(point.getAttribute('lon'));\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    coordinates.push([lon, lat]);\n                }\n            }\n            \n            if (coordinates.length > 0) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: coordinates\n                    },\n                    properties: {\n                        sequence_id: this.extractSequenceIdFromGPX(route) || `gpx_route_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        // Parse waypoints as points\n        const waypoints = xmlDoc.getElementsByTagName('wpt');\n        for (const waypoint of waypoints) {\n            const lat = parseFloat(waypoint.getAttribute('lat'));\n            const lon = parseFloat(waypoint.getAttribute('lon'));\n            if (!isNaN(lat) && !isNaN(lon)) {\n                const nameEl = waypoint.getElementsByTagName('name')[0];\n                const name = nameEl ? nameEl.textContent : '';\n                \n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: [lon, lat]\n                    },\n                    properties: {\n                        name: name,\n                        sequence_id: name || `gpx_waypoint_${features.length + 1}`\n                    }\n                });\n            }\n        }\n        \n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    extractSequenceIdFromGPX(element) {\n        // Try to find sequence ID in name, desc, or extensions\n        const nameEl = element.getElementsByTagName('name')[0];\n        if (nameEl) {\n            const name = nameEl.textContent.trim();\n            // Check if name contains a sequence ID pattern\n            const seqMatch = name.match(/(?:sequence[_\\s]?id|seq[_\\s]?id|id)[:\\s=]+(\\d+)/i);\n            if (seqMatch) {\n                return seqMatch[1];\n            }\n            // If name is just a number, use it as sequence ID\n            if (/^\\d+$/.test(name)) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    parseCSV(csvText) {\n        // Synchronous version for small files (< 100 rows)\n        return this.parseCSVSync(csvText);\n    }\n\n    async parseCSVAsync(csvText, progressCallback) {\n        // Async version for large files - processes in chunks\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        // Parse header\n        const header = this.parseCSVLine(lines[0]);\n        \n        // Find columns (case-insensitive)\n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        // Check if we have lat_long_array format or separate lat/lon columns\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        // Group rows by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalRows = lines.length - 1;\n        const chunkSize = 50; // Process 50 rows at a time\n        \n        for (let start = 1; start < lines.length; start += chunkSize) {\n            const end = Math.min(start + chunkSize, lines.length);\n            \n            for (let i = start; i < end; i++) {\n                const row = this.parseCSVLine(lines[i]);\n                if (row.length === 0) continue;\n                \n                // Get sequence ID\n                let sequenceId;\n                if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                    sequenceId = String(row[sequenceIdIndex]).trim();\n                } else {\n                    const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                    if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                        sequenceId = String(row[groupIndex]).trim();\n                    } else {\n                        sequenceId = `csv_sequence_${i}`;\n                    }\n                }\n                \n                if (!sequenceMap.has(sequenceId)) {\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        coordinates: [],\n                        properties: {},\n                        rowCount: 0\n                    });\n                }\n                \n                const sequence = sequenceMap.get(sequenceId);\n                sequence.rowCount++;\n                \n                // Merge properties\n                if (sequence.rowCount === 1) {\n                    header.forEach((colName, idx) => {\n                        if (row[idx] && row[idx].trim()) {\n                            sequence.properties[colName.trim()] = row[idx].trim();\n                        }\n                    });\n                } else {\n                    header.forEach((colName, idx) => {\n                        const colLower = colName.toLowerCase().trim();\n                        if (row[idx] && row[idx].trim()) {\n                            if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                                try {\n                                    const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                    const newArray = JSON.parse(row[idx].trim());\n                                    if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                        const merged = [...new Set([...existing, ...newArray])];\n                                        sequence.properties[colName] = JSON.stringify(merged);\n                                    }\n                                } catch (e) {\n                                    // Keep existing value if merge fails\n                                }\n                            }\n                        }\n                    });\n                }\n                \n                // Extract coordinates\n                let rowCoordinates = [];\n                if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                    try {\n                        const arrayStr = row[latLongArrayIndex].trim();\n                        const coordArray = JSON.parse(arrayStr);\n                        if (Array.isArray(coordArray)) {\n                            rowCoordinates = coordArray.map(coord => {\n                                if (Array.isArray(coord) && coord.length >= 2) {\n                                    return [parseFloat(coord[1]), parseFloat(coord[0])];\n                                }\n                                return null;\n                            }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                        }\n                    } catch (e) {\n                        // Skip invalid coordinates\n                    }\n                } else if (latIndex >= 0 && lonIndex >= 0) {\n                    const lat = parseFloat(row[latIndex]);\n                    const lon = parseFloat(row[lonIndex]);\n                    if (!isNaN(lat) && !isNaN(lon)) {\n                        rowCoordinates = [[lon, lat]];\n                    }\n                }\n                \n                if (rowCoordinates.length > 0) {\n                    sequence.coordinates.push(...rowCoordinates);\n                }\n            }\n            \n            // Update progress and yield to browser\n            if (progressCallback) {\n                const progress = Math.round(((end - 1) / totalRows) * 100);\n                progressCallback(progress);\n            }\n            \n            // Yield to browser to prevent blocking\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Convert sequences to features\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVSync(csvText) {\n        // Synchronous version for small files\n        const lines = csvText.split('\\n').filter(line => line.trim());\n        if (lines.length < 2) {\n            throw new Error('CSV file must have at least a header row and one data row');\n        }\n\n        const header = this.parseCSVLine(lines[0]);\n        \n        let latLongArrayIndex = -1;\n        let latIndex = -1;\n        let lonIndex = -1;\n        let sequenceIdIndex = -1;\n        \n        const latLongArrayNames = ['lat_long_array', 'latlongarray', 'coordinates', 'coords', 'points'];\n        const latNames = ['lat', 'latitude', 'y', 'ycoord'];\n        const lonNames = ['lon', 'lng', 'longitude', 'long', 'x', 'xcoord'];\n        const seqIdNames = ['offroad_sequence_id', 'sequence_id', 'sequenceid', 'sequence', 'seq', 'id'];\n        \n        header.forEach((col, index) => {\n            const colLower = col.toLowerCase().trim();\n            if (latLongArrayIndex === -1 && latLongArrayNames.some(name => colLower === name)) {\n                latLongArrayIndex = index;\n            }\n            if (latIndex === -1 && latNames.some(name => colLower.includes(name))) {\n                latIndex = index;\n            }\n            if (lonIndex === -1 && lonNames.some(name => colLower.includes(name))) {\n                lonIndex = index;\n            }\n            if (sequenceIdIndex === -1 && seqIdNames.some(name => colLower === name)) {\n                sequenceIdIndex = index;\n            }\n        });\n\n        if (latLongArrayIndex === -1 && (latIndex === -1 || lonIndex === -1)) {\n            throw new Error('CSV must contain either:\\n1. A lat_long_array column with coordinate arrays, OR\\n2. Separate latitude and longitude columns');\n        }\n\n        const sequenceMap = new Map();\n        \n        for (let i = 1; i < lines.length; i++) {\n            const row = this.parseCSVLine(lines[i]);\n            if (row.length === 0) continue;\n            \n            let sequenceId;\n            if (sequenceIdIndex >= 0 && row[sequenceIdIndex] && row[sequenceIdIndex].trim()) {\n                sequenceId = String(row[sequenceIdIndex]).trim();\n            } else {\n                const groupIndex = header.findIndex(col => col.toLowerCase().trim() === 'group');\n                if (groupIndex >= 0 && row[groupIndex] && row[groupIndex].trim()) {\n                    sequenceId = String(row[groupIndex]).trim();\n                } else {\n                    sequenceId = `csv_sequence_${i}`;\n                }\n            }\n            \n            if (!sequenceMap.has(sequenceId)) {\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    coordinates: [],\n                    properties: {},\n                    rowCount: 0\n                });\n            }\n            \n            const sequence = sequenceMap.get(sequenceId);\n            sequence.rowCount++;\n            \n            if (sequence.rowCount === 1) {\n                header.forEach((colName, idx) => {\n                    if (row[idx] && row[idx].trim()) {\n                        sequence.properties[colName.trim()] = row[idx].trim();\n                    }\n                });\n            } else {\n                header.forEach((colName, idx) => {\n                    const colLower = colName.toLowerCase().trim();\n                    if (row[idx] && row[idx].trim()) {\n                        if (colLower === 'bookingcodes' || colLower === 'wheels') {\n                            try {\n                                const existing = JSON.parse(sequence.properties[colName] || '[]');\n                                const newArray = JSON.parse(row[idx].trim());\n                                if (Array.isArray(existing) && Array.isArray(newArray)) {\n                                    const merged = [...new Set([...existing, ...newArray])];\n                                    sequence.properties[colName] = JSON.stringify(merged);\n                                }\n                            } catch (e) {\n                                // Keep existing value\n                            }\n                        }\n                    }\n                });\n            }\n            \n            let rowCoordinates = [];\n            if (latLongArrayIndex >= 0 && row[latLongArrayIndex]) {\n                try {\n                    const arrayStr = row[latLongArrayIndex].trim();\n                    const coordArray = JSON.parse(arrayStr);\n                    if (Array.isArray(coordArray)) {\n                        rowCoordinates = coordArray.map(coord => {\n                            if (Array.isArray(coord) && coord.length >= 2) {\n                                return [parseFloat(coord[1]), parseFloat(coord[0])];\n                            }\n                            return null;\n                        }).filter(coord => coord !== null && !isNaN(coord[0]) && !isNaN(coord[1]));\n                    }\n                } catch (e) {\n                    // Skip invalid\n                }\n            } else if (latIndex >= 0 && lonIndex >= 0) {\n                const lat = parseFloat(row[latIndex]);\n                const lon = parseFloat(row[lonIndex]);\n                if (!isNaN(lat) && !isNaN(lon)) {\n                    rowCoordinates = [[lon, lat]];\n                }\n            }\n            \n            if (rowCoordinates.length > 0) {\n                sequence.coordinates.push(...rowCoordinates);\n            }\n        }\n\n        const features = [];\n        sequenceMap.forEach((sequence) => {\n            if (sequence.coordinates.length === 0) return;\n            \n            sequence.properties.sequence_id = sequence.id;\n            \n            if (sequence.coordinates.length === 1) {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'Point',\n                        coordinates: sequence.coordinates[0]\n                    },\n                    properties: sequence.properties\n                });\n            } else {\n                features.push({\n                    type: 'Feature',\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: sequence.coordinates\n                    },\n                    properties: sequence.properties\n                });\n            }\n        });\n\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    }\n\n    parseCSVLine(line) {\n        // Simple CSV parser that handles quoted fields\n        const result = [];\n        let current = '';\n        let inQuotes = false;\n        \n        for (let i = 0; i < line.length; i++) {\n            const char = line[i];\n            \n            if (char === '\"') {\n                inQuotes = !inQuotes;\n            } else if (char === ',' && !inQuotes) {\n                result.push(current.trim());\n                current = '';\n            } else {\n                current += char;\n            }\n        }\n        result.push(current.trim());\n        \n        return result;\n    }\n\n    processGeoJSON(geojson) {\n        // Synchronous version for small datasets\n        this.processGeoJSONSync(geojson);\n    }\n\n    async processGeoJSONAsync(geojson, progressCallback) {\n        // Async version for large datasets - processes in chunks\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID - process in chunks\n        const sequenceMap = new Map();\n        const totalFeatures = geojson.features.length;\n        const chunkSize = 100; // Process 100 features at a time\n\n        for (let start = 0; start < totalFeatures; start += chunkSize) {\n            const end = Math.min(start + chunkSize, totalFeatures);\n            \n            for (let i = start; i < end; i++) {\n                const feature = geojson.features[i];\n                const sequenceId = String(\n                    feature.properties?.sequence_id || \n                    feature.properties?.sequenceId || \n                    feature.properties?.sequence || \n                    feature.properties?.id ||\n                    feature.properties?.seq ||\n                    `sequence_${i}`\n                );\n\n                if (!sequenceMap.has(sequenceId)) {\n                    const existingStatus = existingStatusMap.get(sequenceId) || '';\n                    sequenceMap.set(sequenceId, {\n                        id: sequenceId,\n                        features: [],\n                        status: existingStatus,\n                        date: new Date().toLocaleDateString()\n                    });\n                }\n\n                sequenceMap.get(sequenceId).features.push(feature);\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = Math.round((end / totalFeatures) * 50); // First 50% for grouping\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Calculate stats in chunks\n        const sequences = Array.from(sequenceMap.values());\n        const processedSequences = [];\n        const statsChunkSize = 50;\n\n        for (let start = 0; start < sequences.length; start += statsChunkSize) {\n            const end = Math.min(start + statsChunkSize, sequences.length);\n            \n            for (let i = start; i < end; i++) {\n                const seq = sequences[i];\n                const stats = this.calculateSequenceStats(seq.features);\n                processedSequences.push({\n                    ...seq,\n                    featureCount: stats.features,\n                    nodeCount: stats.nodes,\n                    wayCount: stats.ways\n                });\n            }\n\n            // Update progress\n            if (progressCallback) {\n                const progress = 50 + Math.round((end / sequences.length) * 50); // Second 50% for stats\n                progressCallback(progress);\n            }\n\n            // Yield to browser\n            await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        // Sort by sequence ID\n        processedSequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        this.sequences = processedSequences;\n        await this.renderTableAsync();\n        this.updateSummary();\n    }\n\n    processGeoJSONSync(geojson) {\n        if (!geojson.features || !Array.isArray(geojson.features)) {\n            console.error('Invalid GeoJSON: missing features array');\n            return;\n        }\n\n        // Preserve existing status values when refreshing\n        const existingStatusMap = new Map();\n        this.sequences.forEach(seq => {\n            if (seq.status) {\n                existingStatusMap.set(String(seq.id), seq.status);\n            }\n        });\n\n        // Group features by sequence ID\n        const sequenceMap = new Map();\n\n        geojson.features.forEach((feature, index) => {\n            const sequenceId = String(\n                feature.properties?.sequence_id || \n                feature.properties?.sequenceId || \n                feature.properties?.sequence || \n                feature.properties?.id ||\n                feature.properties?.seq ||\n                `sequence_${index}`\n            );\n\n            if (!sequenceMap.has(sequenceId)) {\n                const existingStatus = existingStatusMap.get(sequenceId) || '';\n                sequenceMap.set(sequenceId, {\n                    id: sequenceId,\n                    features: [],\n                    status: existingStatus,\n                    date: new Date().toLocaleDateString()\n                });\n            }\n\n            sequenceMap.get(sequenceId).features.push(feature);\n        });\n\n        // Convert to array and calculate stats\n        this.sequences = Array.from(sequenceMap.values()).map(seq => {\n            const stats = this.calculateSequenceStats(seq.features);\n            return {\n                ...seq,\n                featureCount: stats.features,\n                nodeCount: stats.nodes,\n                wayCount: stats.ways\n            };\n        });\n\n        // Sort by sequence ID\n        this.sequences.sort((a, b) => {\n            const aNum = parseInt(a.id);\n            const bNum = parseInt(b.id);\n            if (!isNaN(aNum) && !isNaN(bNum)) {\n                return aNum - bNum;\n            }\n            return a.id.localeCompare(b.id);\n        });\n\n        // Reset to first sequence when new data is loaded\n        this.currentSequenceIndex = 0;\n        \n        this.renderTable();\n        this.updateSummary();\n    }\n\n    calculateSequenceStats(features) {\n        let nodes = 0;\n        let ways = 0;\n\n        features.forEach(feature => {\n            if (feature.geometry) {\n                if (feature.geometry.type === 'Point') {\n                    nodes++;\n                } else if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {\n                    ways++;\n                    if (feature.geometry.coordinates) {\n                        if (Array.isArray(feature.geometry.coordinates[0])) {\n                            nodes += feature.geometry.coordinates.length;\n                        } else {\n                            nodes += 1;\n                        }\n                    }\n                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n                    ways++;\n                    if (feature.geometry.coordinates && feature.geometry.coordinates[0]) {\n                        nodes += feature.geometry.coordinates[0].length;\n                    }\n                }\n            }\n        });\n\n        return {\n            features: features.length,\n            nodes: nodes,\n            ways: ways\n        };\n    }\n\n    getFilteredSequences() {\n        // Always exclude done and skipped tasks (they're on separate pages)\n        return this.sequences.filter(seq => seq.status !== 'done' && seq.status !== 'skipped');\n    }\n\n    renderTable() {\n        // Synchronous version for small datasets\n        this.renderTableSync();\n    }\n\n    async renderTableAsync() {\n        // Async version - shows one sequence at a time\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    updateNavigationControls(totalSequences) {\n        const prevBtn = document.getElementById('prevBtn');\n        const nextBtn = document.getElementById('nextBtn');\n        const counter = document.getElementById('sequenceCounter');\n        const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n\n        if (totalSequences === 0) {\n            if (prevBtn) prevBtn.style.display = 'none';\n            if (nextBtn) nextBtn.style.display = 'none';\n            if (counter) counter.textContent = '';\n            if (exportCurrentBtn) exportCurrentBtn.style.display = 'none';\n            return;\n        }\n\n        // Show navigation controls\n        if (prevBtn) prevBtn.style.display = 'inline-block';\n        if (nextBtn) nextBtn.style.display = 'inline-block';\n        if (exportCurrentBtn) exportCurrentBtn.style.display = 'inline-block';\n        \n        // Update counter\n        if (counter) {\n            counter.textContent = `Sequence ${this.currentSequenceIndex + 1} of ${totalSequences}`;\n        }\n\n        // Enable/disable buttons\n        if (prevBtn) {\n            prevBtn.disabled = this.currentSequenceIndex === 0;\n        }\n        if (nextBtn) {\n            nextBtn.disabled = this.currentSequenceIndex === totalSequences - 1;\n        }\n    }\n\n    showPreviousSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex--;\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n        this.renderTable();\n    }\n\n    showNextSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0) return;\n        \n        this.currentSequenceIndex++;\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        this.renderTable();\n    }\n\n    exportCurrentSequence() {\n        const filteredSequences = this.getFilteredSequences();\n        if (filteredSequences.length === 0 || this.currentSequenceIndex >= filteredSequences.length) {\n            alert('No sequence to export');\n            return;\n        }\n        \n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        this.exportSequence(currentSequence.id);\n    }\n\n    renderTableSync() {\n        const tbody = document.getElementById('taskTableBody');\n        if (!tbody) return;\n\n        tbody.innerHTML = '';\n\n        const filteredSequences = this.getFilteredSequences();\n\n        if (filteredSequences.length === 0) {\n            tbody.innerHTML = `\n                <tr class=\"empty-row\">\n                    <td colspan=\"7\" class=\"empty-message\">\n                        ${this.sequences.length === 0 ? 'No sequences found in GeoJSON file' : 'No active sequences (all tasks are either done or skipped)'}\n                    </td>\n                </tr>\n            `;\n            this.updateNavigationControls(filteredSequences.length);\n            return;\n        }\n\n        // Ensure current index is valid\n        if (this.currentSequenceIndex >= filteredSequences.length) {\n            this.currentSequenceIndex = 0;\n        }\n        if (this.currentSequenceIndex < 0) {\n            this.currentSequenceIndex = filteredSequences.length - 1;\n        }\n\n        // Show only the current sequence\n        const currentSequence = filteredSequences[this.currentSequenceIndex];\n        const row = this.createTableRow(currentSequence);\n        tbody.appendChild(row);\n        \n        this.updateNavigationControls(filteredSequences.length);\n    }\n\n    createTableRow(sequence) {\n        const row = document.createElement('tr');\n        row.dataset.sequenceId = sequence.id;\n\n        const escapedId = String(sequence.id).replace(/'/g, \"\\\\'\");\n        \n        row.innerHTML = `\n            <td class=\"col-id\">${sequence.id}</td>\n            <td class=\"col-status\">\n                <select class=\"status-dropdown\" data-sequence-id=\"${sequence.id}\" onchange=\"taskManager.updateSequenceStatus('${escapedId}', this.value)\">\n                    <option value=\"\" ${!sequence.status || sequence.status === '' ? 'selected' : ''}></option>\n                    <option value=\"skipped\" ${sequence.status === 'skipped' ? 'selected' : ''}>Skipped</option>\n                    <option value=\"done\" ${sequence.status === 'done' ? 'selected' : ''}>Done</option>\n                </select>\n            </td>\n            <td class=\"col-features\">${sequence.featureCount}</td>\n            <td class=\"col-nodes\">${sequence.nodeCount}</td>\n            <td class=\"col-ways\">${sequence.wayCount}</td>\n            <td class=\"col-date\">${sequence.date}</td>\n            <td class=\"col-actions\">\n                <button class=\"btn btn-preview\" onclick=\"taskManager.previewSequence('${escapedId}')\">\n                    ðŸ‘ï¸ Preview\n                </button>\n                <button class=\"btn btn-josm\" onclick=\"taskManager.openInJOSM('${escapedId}')\">\n                    ðŸ—ºï¸ Open in JOSM\n                </button>\n                <button class=\"btn btn-export\" onclick=\"taskManager.exportSequence('${escapedId}')\">\n                    ðŸ“¥ Download\n                </button>\n            </td>\n        `;\n\n        return row;\n    }\n\n\n    exportSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (!sequence) {\n            alert('Sequence not found');\n            return;\n        }\n\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n        } catch (error) {\n            console.error('Export error:', error);\n            alert(`Error exporting sequence: ${error.message}`);\n        }\n    }\n\n    async openInJOSM(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        // Update status\n        try {\n            const josmXml = this.generateJOSMForSequence(sequence);\n            \n            // Use JOSM remote control HTTP API (port 8111)\n            // Method 1: Try POST with data in body (most reliable)\n            const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n            \n            // Try POST method first - JOSM load_data expects data as form parameter\n            // Format: POST to /load_data with body: data=<base64_encoded_xml>\n            fetch('http://localhost:8111/load_data', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: `data=${encodeURIComponent(base64Data)}`,\n                mode: 'no-cors' // Bypass CORS for localhost\n            })\n                .then(() => {\n                    // With no-cors, we can't check response, so assume success\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('POST method failed, trying GET method:', error);\n                    // Fallback: Try GET method\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    return fetch(josmUrl, {\n                        method: 'GET',\n                        mode: 'no-cors'\n                    });\n                })\n                .then(() => {\n                    // If we get here, GET worked\n                    alert('Successfully loaded into JOSM!');\n                })\n                .catch(error => {\n                    console.log('Fetch methods failed, trying iframe method:', error);\n                    // Final fallback: use iframe method (bypasses CORS completely)\n                    const base64Data = btoa(unescape(encodeURIComponent(josmXml)));\n                    const josmUrl = `http://localhost:8111/load_data?data=${encodeURIComponent(base64Data)}`;\n                    const iframe = document.createElement('iframe');\n                    iframe.style.display = 'none';\n                    iframe.src = josmUrl;\n                    document.body.appendChild(iframe);\n                    \n                    // Check if it worked after a delay\n                    setTimeout(() => {\n                        document.body.removeChild(iframe);\n                        const worked = confirm('Attempted to load into JOSM via remote control. Did it work?\\n\\n(If JOSM didn\\'t open or load the data, make sure:\\n1. JOSM is running\\n2. Remote control is enabled in Preferences\\n3. \"Import data from URL\" is checked)\\n\\nWould you like to download the file instead?');\n                        if (!worked) {\n                            this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                        }\n                    }, 2000);\n                });\n        } catch (error) {\n            console.error('JOSM open error:', error);\n            alert(`Error opening in JOSM: ${error.message}`);\n        }\n    }\n\n    async exportAllSelected() {\n        if (this.selectedSequences.size === 0) {\n            alert('Please select at least one sequence to export');\n            return;\n        }\n\n        const selected = Array.from(this.selectedSequences);\n        let exported = 0;\n\n        for (const sequenceId of selected) {\n            let sequence = this.sequences.find(s => s.id === sequenceId);\n            \n            // If sequence doesn't have features, fetch from server\n            if (!sequence || !sequence.features) {\n                try {\n                    sequence = await sequenceAPI.getSequence(String(sequenceId));\n                } catch (error) {\n                    console.error(`Error fetching sequence ${sequenceId}:`, error);\n                    continue;\n                }\n            }\n            \n            if (sequence) {\n                try {\n                    const josmXml = this.generateJOSMForSequence(sequence);\n                    this.downloadFile(josmXml, `sequence_${sequenceId}.osm`, 'application/xml');\n                    exported++;\n                } catch (error) {\n                    console.error(`Error exporting ${sequenceId}:`, error);\n                }\n            }\n        }\n\n        this.renderTable();\n        alert(`Exported ${exported} of ${selected.length} sequences`);\n    }\n\n    generateJOSMForSequence(sequence) {\n        // Default Singapore coordinates\n        const defaultLat = 1.301965;\n        const defaultLng = 103.9003035;\n\n        let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n        xml += '<osm version=\"0.6\" generator=\"OSMAGIC Task Manager\">\\n';\n        xml += `  <!-- Sequence ID: ${sequence.id} -->\\n`;\n        xml += `  <!-- Features: ${sequence.featureCount} -->\\n`;\n        xml += `  <!-- Generated: ${new Date().toISOString()} -->\\n\\n`;\n\n        let nodeId = -1000;\n        let wayId = -1000;\n        const nodeMap = new Map();\n        const nodeTolerance = 0.00001; // ~1 meter\n\n        // Process features and create nodes\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            \n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                \n                if (!nodeMap.has(key)) {\n                    nodeMap.set(key, {\n                        id: nodeId--,\n                        lat: lat,\n                        lon: lon\n                    });\n                }\n            });\n        });\n\n        // Write nodes\n        nodeMap.forEach(node => {\n            xml += `  <node id=\"${node.id}\" lat=\"${node.lat.toFixed(7)}\" lon=\"${node.lon.toFixed(7)}\" version=\"1\" />\\n`;\n        });\n\n        xml += '\\n';\n\n        // Process features and create ways\n        sequence.features.forEach(feature => {\n            if (!feature.geometry) return;\n\n            const coords = this.extractCoordinates(feature.geometry);\n            if (coords.length < 2) return; // Skip points for ways\n\n            xml += `  <way id=\"${wayId--}\" version=\"1\">\\n`;\n\n            coords.forEach(coord => {\n                const [lon, lat] = coord;\n                const key = `${lat.toFixed(7)},${lon.toFixed(7)}`;\n                const node = nodeMap.get(key);\n                if (node) {\n                    xml += `    <nd ref=\"${node.id}\" />\\n`;\n                }\n            });\n\n            // Add tags from properties\n            if (feature.properties) {\n                Object.entries(feature.properties).forEach(([key, value]) => {\n                    if (key !== 'sequence_id' && key !== 'sequenceId' && key !== 'sequence' && key !== 'seq') {\n                        xml += `    <tag k=\"${this.escapeXml(key)}\" v=\"${this.escapeXml(String(value))}\" />\\n`;\n                    }\n                });\n            }\n\n            // Default highway tag if not present\n            if (!feature.properties?.highway) {\n                xml += `    <tag k=\"highway\" v=\"unclassified\" />\\n`;\n            }\n\n            xml += `    <tag k=\"source\" v=\"OSMAGIC Task Manager\" />\\n`;\n            xml += `    <tag k=\"sequence_id\" v=\"${sequence.id}\" />\\n`;\n            xml += `  </way>\\n`;\n        });\n\n        xml += '</osm>';\n        return xml;\n    }\n\n    extractCoordinates(geometry) {\n        const coords = [];\n\n        if (geometry.type === 'Point') {\n            coords.push(geometry.coordinates);\n        } else if (geometry.type === 'LineString') {\n            coords.push(...geometry.coordinates);\n        } else if (geometry.type === 'Polygon') {\n            if (geometry.coordinates && geometry.coordinates[0]) {\n                coords.push(...geometry.coordinates[0]);\n            }\n        } else if (geometry.type === 'MultiLineString') {\n            geometry.coordinates.forEach(line => {\n                coords.push(...line);\n            });\n        } else if (geometry.type === 'MultiPolygon') {\n            geometry.coordinates.forEach(polygon => {\n                if (polygon[0]) {\n                    coords.push(...polygon[0]);\n                }\n            });\n        }\n\n        return coords;\n    }\n\n    escapeXml(text) {\n        return String(text)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&apos;');\n    }\n\n    downloadFile(content, filename, mimeType) {\n        const blob = new Blob([content], { type: mimeType });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n    }\n\n\n    async updateSequenceStatus(sequenceId, newStatus) {\n        const idStr = String(sequenceId);\n        const sequence = this.sequences.find(s => String(s.id) === idStr);\n        if (sequence) {\n            const oldStatus = sequence.status;\n            sequence.status = newStatus;\n            \n            // If marked as \"done\", save to completed tasks\n            if (newStatus === 'done') {\n                await this.saveCompletedTask(sequence);\n                // Remove from skipped if it was skipped\n                if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            } \n            // If marked as \"skipped\", save to skipped tasks\n            else if (newStatus === 'skipped') {\n                await this.saveSkippedTask(sequence);\n                // Remove from completed if it was done\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                }\n            }\n            // If unmarking from \"done\" or \"skipped\", remove from respective lists\n            else {\n                if (oldStatus === 'done') {\n                    await this.removeCompletedTask(sequenceId);\n                } else if (oldStatus === 'skipped') {\n                    await this.removeSkippedTask(sequenceId);\n                }\n            }\n            \n            // Save metadata to cache (and upload to server if needed)\n            await this.uploadToServerAndSave();\n            \n            this.renderTable(); // Re-render to apply filter\n            this.updateSummary(); // Update summary counts\n        }\n    }\n\n    async saveCompletedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                completedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveCompletedTask(taskData);\n        } catch (error) {\n            console.error('Error saving completed task:', error);\n        }\n    }\n\n    async removeCompletedTask(sequenceId) {\n        try {\n            await storageManager.removeCompletedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing completed task:', error);\n        }\n    }\n\n    async getCompletedTasks() {\n        try {\n            return await storageManager.getAllCompletedTasks();\n        } catch (error) {\n            console.error('Error loading completed tasks:', error);\n            return [];\n        }\n    }\n\n    async saveSkippedTask(sequence) {\n        try {\n            // OPTIMIZATION: Don't store full features - only store metadata\n            // Features can be reconstructed from geojsonData when needed for preview/export\n            const taskData = {\n                id: String(sequence.id),\n                status: sequence.status,\n                featureCount: sequence.featureCount,\n                nodeCount: sequence.nodeCount,\n                wayCount: sequence.wayCount,\n                date: sequence.date,\n                skippedDate: new Date().toISOString()\n                // Don't store features - reconstruct from geojsonData when needed\n            };\n            \n            await storageManager.saveSkippedTask(taskData);\n        } catch (error) {\n            console.error('Error saving skipped task:', error);\n        }\n    }\n\n    async removeSkippedTask(sequenceId) {\n        try {\n            await storageManager.removeSkippedTask(sequenceId);\n        } catch (error) {\n            console.error('Error removing skipped task:', error);\n        }\n    }\n\n    async getSkippedTasks() {\n        try {\n            return await storageManager.getAllSkippedTasks();\n        } catch (error) {\n            console.error('Error loading skipped tasks:', error);\n            return [];\n        }\n    }\n\n    updateSummary() {\n        const summary = document.getElementById('summaryInfo');\n        const filteredSequences = this.getFilteredSequences();\n        const totalFeatures = this.sequences.reduce((sum, seq) => sum + seq.featureCount, 0);\n        const doneCount = this.sequences.filter(seq => seq.status === 'done').length;\n        const skippedCount = this.sequences.filter(seq => seq.status === 'skipped').length;\n        const blankCount = this.sequences.filter(seq => !seq.status || seq.status === '').length;\n\n        summary.innerHTML = `\n            <span>Total Sequences: ${this.sequences.length}</span>\n            <span>Showing: ${filteredSequences.length}</span>\n            <span>Total Features: ${totalFeatures}</span>\n            <span>Done: ${doneCount}</span>\n            <span>Skipped: ${skippedCount}</span>\n            <span>Blank: ${blankCount}</span>\n        `;\n    }\n\n    async previewSequence(sequenceId) {\n        // Convert to string for comparison\n        const idStr = String(sequenceId);\n        let sequence = this.sequences.find(s => String(s.id) === idStr);\n        \n        // If sequence doesn't have features, fetch from server\n        if (!sequence || !sequence.features) {\n            try {\n                sequence = await sequenceAPI.getSequence(idStr);\n            } catch (error) {\n                console.warn('Failed to fetch from server, using local data:', error);\n                if (!sequence) {\n                    alert('Sequence not found');\n                    return;\n                }\n            }\n        }\n\n        this.currentPreviewSequence = sequence;\n        document.getElementById('previewSequenceId').textContent = idStr;\n        \n        // Show modal\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'block';\n\n        // Initialize map - need to wait a bit for modal to be visible\n        setTimeout(() => {\n            if (!this.map) {\n                this.map = L.map('previewMap', {\n                    zoomControl: true\n                }).setView([1.301965, 103.9003035], 13);\n                \n                // Add OpenStreetMap tile layer\n                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                    attribution: 'Â© OpenStreetMap contributors',\n                    maxZoom: 19\n                }).addTo(this.map);\n            }\n\n            // Clear existing GeoJSON layers (but keep tile layer)\n            this.map.eachLayer((layer) => {\n                if (layer instanceof L.GeoJSON) {\n                    this.map.removeLayer(layer);\n                }\n            });\n\n            // Create GeoJSON from sequence features\n            const geojson = {\n                type: 'FeatureCollection',\n                features: sequence.features\n            };\n\n            // Add GeoJSON layer to map\n            const geoJsonLayer = L.geoJSON(geojson, {\n                style: (feature) => {\n                    return {\n                        color: '#3388ff',\n                        weight: 4,\n                        opacity: 0.8\n                    };\n                },\n                onEachFeature: (feature, layer) => {\n                    if (feature.properties) {\n                        const props = Object.entries(feature.properties)\n                            .map(([key, value]) => `${key}: ${value}`)\n                            .join('<br>');\n                        layer.bindPopup(`<strong>Properties:</strong><br>${props}`);\n                    }\n                }\n            }).addTo(this.map);\n\n            // Invalidate size to ensure map renders correctly\n            setTimeout(() => {\n                this.map.invalidateSize();\n                \n                // Fit map to bounds\n                if (geoJsonLayer.getBounds().isValid()) {\n                    this.map.fitBounds(geoJsonLayer.getBounds(), { padding: [50, 50] });\n                } else {\n                    // Fallback to Singapore if bounds are invalid\n                    this.map.setView([1.301965, 103.9003035], 13);\n                }\n            }, 200);\n        }, 300);\n    }\n\n    closePreview() {\n        const modal = document.getElementById('previewModal');\n        modal.style.display = 'none';\n        this.currentPreviewSequence = null;\n        \n        // Invalidate map size when hidden\n        if (this.map) {\n            setTimeout(() => {\n                this.map.invalidateSize();\n            }, 100);\n        }\n    }\n\n    exportFromPreview() {\n        if (this.currentPreviewSequence) {\n            this.exportSequence(this.currentPreviewSequence.id);\n            this.closePreview();\n        }\n    }\n\n    async uploadToServerAndSave() {\n        try {\n            // Upload full dataset to server (if available)\n            if (this.geojsonData && this.sequences.length > 0) {\n                try {\n                    await sequenceAPI.uploadDataset(this.geojsonData, this.sequences);\n                    console.log('Dataset uploaded to server successfully');\n                } catch (serverError) {\n                    console.warn('Server upload failed, falling back to local storage:', serverError);\n                    // Fallback to local storage if server is not available\n                    await this.saveToCacheLocal();\n                    return;\n                }\n            }\n            \n            // Save only metadata to local cache (no GeoJSON data)\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                sequences: activeSequences, // Only metadata, no features, no geojsonData\n                timestamp: new Date().toISOString(),\n                serverMode: true // Flag to indicate server-side storage\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error uploading to server:', error);\n            // Fallback to local storage\n            await this.saveToCacheLocal();\n        }\n    }\n\n    async saveToCacheLocal() {\n        // Fallback: Save to local storage if server is unavailable\n        try {\n            const activeSequences = this.sequences\n                .filter(seq => seq.status !== 'done' && seq.status !== 'skipped')\n                .map(seq => ({\n                    id: seq.id,\n                    status: seq.status,\n                    featureCount: seq.featureCount,\n                    nodeCount: seq.nodeCount,\n                    wayCount: seq.wayCount,\n                    date: seq.date\n                }));\n            \n            const cacheData = {\n                geojsonData: this.geojsonData, // Store full GeoJSON locally as fallback\n                sequences: activeSequences,\n                timestamp: new Date().toISOString(),\n                serverMode: false\n            };\n            await storageManager.saveActiveTasksCache(cacheData);\n        } catch (error) {\n            console.error('Error saving to local cache:', error);\n            alert('Error saving data. Your browser storage may be full.');\n        }\n    }\n\n    async loadFromCache() {\n        try {\n            const cacheData = await storageManager.loadActiveTasksCache();\n            if (!cacheData) return;\n\n            // Check if we're in server mode\n            if (cacheData.serverMode) {\n                // Try to load from server\n                try {\n                    const serverAvailable = await sequenceAPI.checkServerStatus();\n                    if (serverAvailable) {\n                        // Load GeoJSON from server\n                        this.geojsonData = await sequenceAPI.getGeoJSON();\n                        // Reprocess to get sequences\n                        this.processGeoJSON(this.geojsonData);\n                        // Restore status from cached sequences\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        throw new Error('Server not available');\n                    }\n                } catch (serverError) {\n                    console.warn('Server not available, trying local fallback:', serverError);\n                    // Fallback to local storage if available\n                    if (cacheData.geojsonData) {\n                        this.geojsonData = cacheData.geojsonData;\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else {\n                        console.warn('No local fallback data available');\n                        return;\n                    }\n                }\n            } else {\n                // Legacy mode: load from local storage\n                if (cacheData.geojsonData) {\n                    this.geojsonData = cacheData.geojsonData;\n                }\n                \n                if (cacheData.sequences && Array.isArray(cacheData.sequences)) {\n                    if (cacheData.geojsonData) {\n                        this.processGeoJSON(cacheData.geojsonData);\n                        const statusMap = new Map();\n                        cacheData.sequences.forEach(seq => {\n                            statusMap.set(String(seq.id), seq.status);\n                        });\n                        this.sequences.forEach(seq => {\n                            const cachedStatus = statusMap.get(String(seq.id));\n                            if (cachedStatus !== undefined) {\n                                seq.status = cachedStatus;\n                            }\n                        });\n                    } else if (cacheData.sequences.length > 0 && cacheData.sequences[0].features) {\n                        this.sequences = cacheData.sequences;\n                    }\n                }\n            }\n            \n            // Render table if we have data\n            if (this.sequences.length > 0) {\n                this.renderTable();\n                this.updateSummary();\n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = false;\n                }\n            }\n        } catch (error) {\n            console.error('Error loading from cache:', error);\n        }\n    }\n\n    async loadFileInfo() {\n        try {\n            const fileInfo = await storageManager.loadFileInfo();\n            const fileInfoElement = document.getElementById('fileInfo');\n            if (fileInfo && fileInfoElement) {\n                fileInfoElement.textContent = fileInfo;\n            }\n        } catch (error) {\n            console.error('Error loading file info:', error);\n        }\n    }\n\n    async finishReview() {\n        if (confirm('Finish reviewing this project?\\n\\nThis will clear:\\nâ€¢ All active tasks\\nâ€¢ All skipped tasks\\nâ€¢ All completed tasks\\nâ€¢ All uploaded files\\nâ€¢ Server data\\n\\nData will be permanently removed. This action cannot be undone!')) {\n            try {\n                // Clear server data first\n                try {\n                    await sequenceAPI.clearAll();\n                    console.log('Server data cleared');\n                } catch (serverError) {\n                    console.warn('Could not clear server data (server may not be running):', serverError);\n                }\n                \n                // Clear all caches from IndexedDB - this clears everything\n                // Wait for the transaction to complete\n                await storageManager.clearAllData();\n                \n                // Small delay to ensure transaction completes\n                await new Promise(resolve => setTimeout(resolve, 200));\n                \n                // Double-check: Verify data is cleared\n                let completedTasks = await storageManager.getAllCompletedTasks();\n                let skippedTasks = await storageManager.getAllSkippedTasks();\n                \n                if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                    console.warn('Some data still exists, force clearing...');\n                    // Force clear again with individual calls\n                    await storageManager.clearAllSkippedTasks();\n                    await storageManager.clearAllCompletedTasks();\n                    await storageManager.clearActiveTasksCache();\n                    await storageManager.clearFileInfo();\n                    \n                    // Wait again\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Use force clear method to delete by key\n                    await storageManager.forceClearAllData();\n                    \n                    // Wait once more\n                    await new Promise(resolve => setTimeout(resolve, 200));\n                    \n                    // Verify again\n                    completedTasks = await storageManager.getAllCompletedTasks();\n                    skippedTasks = await storageManager.getAllSkippedTasks();\n                    \n                    if (completedTasks.length > 0 || skippedTasks.length > 0) {\n                        console.error('Data still exists after clearing:', {\n                            completed: completedTasks.length,\n                            skipped: skippedTasks.length\n                        });\n                        // Log the IDs that remain\n                        if (completedTasks.length > 0) {\n                            console.error('Remaining completed tasks:', completedTasks.map(t => t.id));\n                        }\n                        if (skippedTasks.length > 0) {\n                            console.error('Remaining skipped tasks:', skippedTasks.map(t => t.id));\n                        }\n                    }\n                }\n                \n                // Reset local data\n                this.geojsonData = null;\n                this.sequences = [];\n                this.selectedSequences.clear();\n                this.currentSequenceIndex = 0;\n                \n                // Clear file input\n                const fileInput = document.getElementById('geojsonFileInput');\n                if (fileInput) {\n                    fileInput.value = '';\n                }\n                \n                // Clear file info\n                const fileInfo = document.getElementById('fileInfo');\n                if (fileInfo) {\n                    fileInfo.textContent = '';\n                }\n                \n                // Re-render\n                this.renderTable();\n                this.updateSummary();\n                this.updateNavigationControls(0);\n                \n                const exportBtn = document.getElementById('exportAllBtn');\n                if (exportBtn) {\n                    exportBtn.disabled = true;\n                }\n                \n                const exportCurrentBtn = document.getElementById('exportCurrentBtn');\n                if (exportCurrentBtn) {\n                    exportCurrentBtn.style.display = 'none';\n                }\n                \n                // Set a timestamp to indicate data was cleared\n                // This will be checked by other pages when they become visible\n                try {\n                    const clearTimestamp = Date.now().toString();\n                    localStorage.setItem('taskManagerDataCleared', clearTimestamp);\n                    // Also set a flag that persists\n                    localStorage.setItem('taskManagerDataClearedFlag', clearTimestamp);\n                    // Trigger storage event (works across tabs)\n                    // Note: storage event only fires in OTHER tabs, not the current one\n                    setTimeout(() => {\n                        localStorage.removeItem('taskManagerDataCleared');\n                    }, 100);\n                } catch (e) {\n                    console.warn('Could not trigger storage event:', e);\n                }\n                \n                alert('Project review completed! All data has been cleared.\\n\\nThe Skipped and Completed pages will automatically refresh when you switch to them.');\n            } catch (error) {\n                console.error('Error finishing review:', error);\n                alert('Error clearing data: ' + error.message + '\\n\\nPlease try again.');\n            }\n        }\n    }\n}\n\n// Initialize task manager when page loads\nlet taskManager;\ndocument.addEventListener('DOMContentLoaded', () => {\n    taskManager = new TaskManager();\n});\n\n\n",
        "task-manager.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>OSMAGIC Task Manager</title>\n    <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" />\n    <link rel=\"stylesheet\" href=\"task-manager.css\">\n    <script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"></script>\n    <script src=\"sequence-api.js\"></script>\n</head>\n<body>\n    <div class=\"task-manager-container\">\n        <header class=\"task-header\">\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                <div>\n                    <h1>ðŸ“‹ OSMAGIC Task Manager</h1>\n                    <p>Manage and export GeoJSON sequences as individual JOSM files</p>\n                </div>\n                <div style=\"display: flex; gap: 10px;\">\n                    <a href=\"skipped-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        â­ï¸ Skipped Tasks\n                    </a>\n                    <a href=\"completed-tasks.html\" class=\"btn btn-secondary\" style=\"text-decoration: none; white-space: nowrap;\">\n                        âœ… Completed Tasks\n                    </a>\n                </div>\n            </div>\n        </header>\n\n        <div class=\"upload-section\">\n            <div class=\"upload-panel\">\n                <h3>ðŸ“ Upload Files</h3>\n                    <div class=\"file-upload\">\n                        <input type=\"file\" id=\"geojsonFileInput\" accept=\".geojson,.json,.gpx,.csv\" multiple />\n                        <label for=\"geojsonFileInput\" class=\"upload-button\">\n                            Choose Files (GeoJSON/GPX/CSV) - Multiple files supported\n                        </label>\n                    </div>\n                    <div class=\"format-info\" style=\"margin-top: 10px; font-size: 0.85em; color: #666;\">\n                        <strong>Supported formats:</strong>\n                        <ul style=\"margin: 5px 0; padding-left: 20px;\">\n                            <li>GeoJSON (.geojson, .json)</li>\n                            <li>GPX (.gpx)</li>\n                            <li>CSV (.csv) - with lat/lon columns</li>\n                        </ul>\n                    </div>\n                <div class=\"file-info\" id=\"fileInfo\"></div>\n            </div>\n        </div>\n\n        <div class=\"table-container\">\n            <div class=\"table-header\">\n                <h3>ðŸ“Š Sequence Tasks</h3>\n                <div class=\"table-controls\">\n                    <button id=\"prevBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showPreviousSequence()\" style=\"display: none;\">\n                        â† Previous\n                    </button>\n                    <span id=\"sequenceCounter\" style=\"margin: 0 10px; font-weight: 600;\"></span>\n                    <button id=\"nextBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.showNextSequence()\" style=\"display: none;\">\n                        Next â†’\n                    </button>\n                    <button id=\"exportCurrentBtn\" class=\"btn btn-primary\" onclick=\"taskManager.exportCurrentSequence()\" style=\"display: none;\">\n                        ðŸ“¥ Export Current\n                    </button>\n                    <button id=\"finishReviewBtn\" class=\"btn btn-secondary\" onclick=\"taskManager.finishReview()\" style=\"margin-left: 10px;\">\n                        âœ… Finish Review\n                    </button>\n                </div>\n            </div>\n\n            <div class=\"excel-table-wrapper\">\n                <table class=\"excel-table\" id=\"taskTable\">\n                    <thead>\n                        <tr>\n                            <th class=\"col-id\">Sequence ID</th>\n                            <th class=\"col-status\">Status</th>\n                            <th class=\"col-features\">Features</th>\n                            <th class=\"col-nodes\">Nodes</th>\n                            <th class=\"col-ways\">Ways</th>\n                            <th class=\"col-date\">Date</th>\n                            <th class=\"col-actions\">Actions</th>\n                        </tr>\n                    </thead>\n                    <tbody id=\"taskTableBody\">\n                        <tr class=\"empty-row\">\n                            <td colspan=\"8\" class=\"empty-message\">\n                                Upload a GeoJSON file to begin\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </div>\n\n            <div class=\"table-footer\">\n                <div class=\"summary-info\" id=\"summaryInfo\">\n                    <span>Total Sequences: 0</span>\n                    <span>Total Features: 0</span>\n                    <span>Ready to Export: 0</span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Preview Modal -->\n    <div id=\"previewModal\" class=\"modal\" onclick=\"if(event.target.id === 'previewModal') taskManager.closePreview()\">\n        <div class=\"modal-content\" onclick=\"event.stopPropagation()\">\n            <div class=\"modal-header\">\n                <h2>ðŸ—ºï¸ GPS Trace Preview - Sequence ID: <span id=\"previewSequenceId\"></span></h2>\n                <button class=\"modal-close\" onclick=\"taskManager.closePreview()\">&times;</button>\n            </div>\n            <div class=\"modal-body\">\n                <div id=\"previewMap\" class=\"preview-map\"></div>\n                <div class=\"preview-actions\">\n                    <button class=\"btn btn-primary\" onclick=\"taskManager.exportFromPreview()\">\n                        ðŸ“¥ Export JOSM\n                    </button>\n                    <button class=\"btn btn-secondary\" onclick=\"taskManager.closePreview()\">\n                        Close\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"storage-utils.js\"></script>\n    <script src=\"task-manager.js\"></script>\n</body>\n</html>\n\n",
        "task-manager.css": "* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    background: #f5f5f5;\n    min-height: 100vh;\n    color: #333;\n}\n\n.task-manager-container {\n    max-width: 1800px;\n    margin: 0 auto;\n    padding: 20px;\n    min-height: 100vh;\n    display: flex;\n    flex-direction: column;\n}\n\n.task-header {\n    background: white;\n    padding: 20px 30px;\n    border-radius: 8px;\n    margin-bottom: 20px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.task-header h1 {\n    color: #2c3e50;\n    margin-bottom: 5px;\n    font-size: 2em;\n}\n\n.task-header p {\n    color: #7f8c8d;\n    font-size: 1em;\n}\n\n.upload-section {\n    margin-bottom: 20px;\n}\n\n.upload-panel {\n    background: white;\n    padding: 20px;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n\n.upload-panel h3 {\n    margin-bottom: 15px;\n    color: #2c3e50;\n}\n\n.file-upload {\n    display: flex;\n    align-items: center;\n    gap: 15px;\n}\n\n.file-upload input[type=\"file\"] {\n    display: none;\n}\n\n.upload-button {\n    display: inline-block;\n    padding: 10px 20px;\n    background: #3498db;\n    color: white;\n    border-radius: 5px;\n    cursor: pointer;\n    transition: background 0.3s;\n    font-weight: 500;\n}\n\n.upload-button:hover {\n    background: #2980b9;\n}\n\n.google-sheets-section {\n    display: flex;\n    gap: 10px;\n    margin-bottom: 10px;\n}\n\n.google-sheets-sync {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n}\n\n.google-sheets-sync .sheet-input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.google-sheets-sync .btn-google {\n    width: 100%;\n    padding: 10px;\n    white-space: nowrap;\n}\n\n#sheetStatus {\n    padding: 8px;\n    border-radius: 4px;\n    background: #f8f9fa;\n}\n\n.sheet-input {\n    flex: 1;\n    padding: 10px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    font-size: 0.9em;\n}\n\n.sheet-input:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.btn-google {\n    background: #34a853;\n    color: white;\n    padding: 10px 20px;\n    white-space: nowrap;\n}\n\n.btn-google:hover {\n    background: #2d8f47;\n}\n\n.file-info {\n    margin-top: 10px;\n    padding: 10px;\n    background: #ecf0f1;\n    border-radius: 5px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.table-container {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    background: white;\n    border-radius: 8px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n    overflow: hidden;\n}\n\n.table-header {\n    padding: 15px 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n}\n\n.table-header h3 {\n    color: #2c3e50;\n    font-size: 1.2em;\n}\n\n.table-controls {\n    display: flex;\n    gap: 10px;\n}\n\n.btn {\n    padding: 8px 16px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    font-weight: 500;\n    transition: all 0.3s;\n}\n\n.btn-primary {\n    background: #27ae60;\n    color: white;\n}\n\n.btn-primary:hover:not(:disabled) {\n    background: #229954;\n}\n\n.btn-secondary {\n    background: #95a5a6;\n    color: white;\n}\n\n.btn-secondary:hover:not(:disabled) {\n    background: #7f8c8d;\n}\n\n.btn:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n}\n\n.btn-export {\n    background: #3498db;\n    color: white;\n    padding: 6px 12px;\n    font-size: 0.85em;\n}\n\n.btn-export:hover {\n    background: #2980b9;\n}\n\n.excel-table-wrapper {\n    flex: 1;\n    overflow: auto;\n    border: 1px solid #d0d0d0;\n}\n\n.excel-table {\n    width: 100%;\n    border-collapse: collapse;\n    background: white;\n    font-size: 0.9em;\n}\n\n.excel-table thead {\n    background: #f0f0f0;\n    position: sticky;\n    top: 0;\n    z-index: 10;\n}\n\n.excel-table th {\n    padding: 12px 10px;\n    text-align: left;\n    font-weight: 600;\n    color: #2c3e50;\n    border: 1px solid #d0d0d0;\n    background: #f0f0f0;\n    white-space: nowrap;\n}\n\n.excel-table td {\n    padding: 10px;\n    border: 1px solid #e0e0e0;\n    background: white;\n}\n\n.excel-table tbody tr {\n    transition: background 0.2s;\n}\n\n.excel-table tbody tr:hover {\n    background: #f8f9fa;\n}\n\n.excel-table tbody tr.selected {\n    background: #e3f2fd;\n}\n\n.excel-table tbody tr.empty-row td {\n    text-align: center;\n    color: #999;\n    font-style: italic;\n    padding: 40px;\n}\n\n/* Column widths */\n.col-checkbox {\n    width: 50px;\n    text-align: center;\n}\n\n.col-id {\n    width: 150px;\n    font-weight: 600;\n    color: #2c3e50;\n}\n\n.col-status {\n    width: 120px;\n}\n\n.col-features {\n    width: 100px;\n    text-align: center;\n}\n\n.col-nodes {\n    width: 100px;\n    text-align: center;\n}\n\n.col-ways {\n    width: 100px;\n    text-align: center;\n}\n\n.col-date {\n    width: 150px;\n}\n\n.col-actions {\n    width: 180px;\n    text-align: center;\n}\n\n.filter-controls {\n    display: flex;\n    align-items: center;\n    margin-right: 15px;\n}\n\n.status-filter {\n    padding: 6px 10px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.9em;\n    background: white;\n    cursor: pointer;\n}\n\n.status-filter:hover {\n    border-color: #3498db;\n}\n\n.status-filter:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n.col-actions .btn {\n    margin: 2px;\n    padding: 5px 10px;\n    font-size: 0.8em;\n}\n\n.btn-preview {\n    background: #9b59b6;\n    color: white;\n}\n\n.btn-preview:hover {\n    background: #8e44ad;\n}\n\n.btn-josm {\n    background: #e74c3c;\n    color: white;\n}\n\n.btn-josm:hover {\n    background: #c0392b;\n}\n\n/* Status dropdown */\n.status-dropdown {\n    width: 100%;\n    padding: 6px 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    font-size: 0.85em;\n    background: white;\n    cursor: pointer;\n    transition: all 0.2s;\n}\n\n.status-dropdown:hover {\n    border-color: #3498db;\n}\n\n.status-dropdown:focus {\n    outline: none;\n    border-color: #3498db;\n    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);\n}\n\n/* Status badge styles (kept for reference, but using dropdown now) */\n.status-badge {\n    display: inline-block;\n    padding: 4px 10px;\n    border-radius: 12px;\n    font-size: 0.85em;\n    font-weight: 500;\n}\n\n.status-ready {\n    background: #d4edda;\n    color: #155724;\n}\n\n.status-processing {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.status-completed {\n    background: #cce5ff;\n    color: #004085;\n}\n\n.status-error {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n/* Checkbox styling */\ninput[type=\"checkbox\"] {\n    width: 18px;\n    height: 18px;\n    cursor: pointer;\n}\n\n.table-footer {\n    padding: 15px 20px;\n    border-top: 2px solid #e0e0e0;\n    background: #f8f9fa;\n}\n\n.summary-info {\n    display: flex;\n    gap: 30px;\n    font-size: 0.9em;\n    color: #555;\n}\n\n.summary-info span {\n    font-weight: 500;\n}\n\n/* Loading spinner */\n.loading {\n    display: inline-block;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #f3f3f3;\n    border-top: 2px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n/* Modal Styles */\n.modal {\n    display: none;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.7);\n    overflow: auto;\n}\n\n.modal-content {\n    background-color: white;\n    margin: 2% auto;\n    padding: 0;\n    border-radius: 8px;\n    width: 90%;\n    max-width: 1400px;\n    max-height: 90vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.modal-header {\n    padding: 20px;\n    border-bottom: 2px solid #e0e0e0;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    background: #f8f9fa;\n    border-radius: 8px 8px 0 0;\n}\n\n.modal-header h2 {\n    margin: 0;\n    color: #2c3e50;\n    font-size: 1.5em;\n}\n\n.modal-close {\n    background: none;\n    border: none;\n    font-size: 2em;\n    color: #999;\n    cursor: pointer;\n    padding: 0;\n    width: 40px;\n    height: 40px;\n    line-height: 40px;\n    text-align: center;\n    border-radius: 50%;\n    transition: all 0.3s;\n}\n\n.modal-close:hover {\n    background: #e0e0e0;\n    color: #333;\n}\n\n.modal-body {\n    padding: 20px;\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.preview-map {\n    width: 100%;\n    height: 600px;\n    min-height: 600px;\n    border: 1px solid #ddd;\n    border-radius: 5px;\n    margin-bottom: 15px;\n    z-index: 1;\n    position: relative;\n}\n\n/* Fix Leaflet map container */\n#previewMap {\n    width: 100% !important;\n    height: 100% !important;\n    min-height: 600px;\n}\n\n.preview-actions {\n    display: flex;\n    gap: 10px;\n    justify-content: flex-end;\n    padding-top: 15px;\n    border-top: 1px solid #e0e0e0;\n}\n\n"
      }
    }
  ],
  "currentPromptNumber": 6
}